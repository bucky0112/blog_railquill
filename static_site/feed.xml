<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom" xmlns:content="http://purl.org/rss/1.0/modules/content/">
  <channel>
    <title>Railquill</title>
    <link>https://railquill.vercel.app</link>
    <description>Thoughts on Ruby, Rails, and building beautiful web applications. Join me on this journey of continuous learning and clean code.</description>
    <language>en-us</language>
    <atom:link href="https://railquill.vercel.app/feed.xml" rel="self" type="application/rss+xml" />
    <lastBuildDate>Fri, 19 Sep 2025 18:54:59 +0000</lastBuildDate>
    <generator>Railquill - Rails Blog Generator</generator>
    
    <item>
      <title>用 Rust + Bevy 打造一個簡化版「雷電」射擊遊戲</title>
      <link>https://railquill.vercel.app/rust-bevy-Raiden.html</link>
      <description>小時候在大型機台玩《雷電》時，總覺得能自己做出一個射擊遊戲一定很酷。

現在算是實現了，而且還是用 Rust
...</description>
      <content:encoded><![CDATA[
          <img src="https://github.com/bucky0112/blog-images/blob/main/images/ferris_plane.webp?raw=true" alt="Bevy version Raiden" style="max-width: 100%; height: auto; margin-bottom: 1rem;" />
        &lt;p&gt;小時候在大型機台玩《雷電》時，總覺得能自己做出一個射擊遊戲一定很酷。最近我正好在研究 Rust 的遊戲引擎 &lt;a href=&quot;https://bevy.org/&quot;&gt;Bevy&lt;/a&gt;，挑戰做出一個簡化版的經典射擊遊戲 &lt;strong&gt;雷電 (Raiden)&lt;/strong&gt;。&lt;/p&gt;

&lt;p&gt;這個 Demo 包含以下功能：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;玩家可以用 WASD / 方向鍵 移動飛機&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;按 空白鍵 發射子彈&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;敵人會自動生成並從上方往下移動&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;子彈擊中敵人 → 敵人與子彈同時消失&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;超出畫面的物件會自動清理&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最終效果大概是這樣：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://raw.githubusercontent.com/bucky0112/blog-images/main/images/img_20250919_000255.gif&quot; alt=&quot;demo&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;bevy&quot;&gt;Bevy 為什麼適合這個題材？&lt;/h2&gt;

&lt;p&gt;Bevy 採用 ECS（Entity Component System） 架構，把遊戲物件拆成三個元素：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Entity（實體）：玩家、敵人、子彈&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Component（元件）：位置、速度、角色類型&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;System（系統）：移動、生成、碰撞、清理&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;對「射擊遊戲」來說，這個架構超直觀：敵人就是一個 entity，子彈也是，給它一個 velocity component，它們就會自己動起來。&lt;/p&gt;

&lt;h2 id=&quot;part-2d1a51ebcd84e3ca&quot;&gt;玩家控制&lt;/h2&gt;

&lt;p&gt;玩家飛機的操作就是 方向鍵 / WASD。這裡我加了一個小細節：玩家不能飛出螢幕邊界。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;transform.translation.x = transform.translation.x
    .clamp(-WINDOW_WIDTH / 2.0 + 25.0, WINDOW_WIDTH / 2.0 - 25.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這行程式碼就是用來「把你擋在畫面裡」。我一開始還忘了加，結果飛機直接飛出視窗消失XD&lt;/p&gt;

&lt;h2 id=&quot;part-6542ac97d61&quot;&gt;射擊&lt;/h2&gt;

&lt;p&gt;只要按空白鍵，玩家就能發射一顆黃色小子彈往上飛。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;commands.spawn((
    Sprite {
        color: Color::srgb(1.0, 1.0, 0.0),
        custom_size: Some(Vec2::new(5.0, 10.0)),
        ..default()
    },
    Transform::from_xyz(player_x, player_y + 30.0, 0.0),
    Bullet,
    Velocity(Vec3::new(0.0, BULLET_SPEED, 0.0)),
));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;子彈就是一個矩形精靈，加上 Velocity，剩下交給移動系統就好。
第一次按下空白鍵，看到畫面裡飛出黃色子彈的瞬間，彷彿夢回童年。&lt;/p&gt;

&lt;h2 id=&quot;part-2d39d1bed1bb5444&quot;&gt;產生敵人&lt;/h2&gt;

&lt;p&gt;敵人每隔兩秒會在隨機位置生成，然後慢慢往下移動：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x = (rand::random::&amp;lt;f32&amp;gt;() - 0.5) * (WINDOW_WIDTH - 100.0);
commands.spawn((
    Sprite::from_image(asset_server.load(&quot;player2.png&quot;)),
    Transform::from_xyz(x, WINDOW_HEIGHT / 2.0 + 50.0, 0.0),
    Enemy,
    Velocity(Vec3::new(0.0, -ENEMY_SPEED, 0.0)),
));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;當我第一次看到敵人真的「一架一架掉下來」時，瞬間覺得好像真的可以玩了 😎。&lt;/p&gt;

&lt;h2 id=&quot;part-2d884cd2bcd875b0&quot;&gt;碰撞檢測&lt;/h2&gt;

&lt;p&gt;子彈跟敵人碰到就同歸於盡，這裡我用了最直白的寫法：算距離。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;if bullet_transform.translation.distance(enemy_transform.translation) &amp;lt; 30.0 {
    commands.entity(bullet_entity).despawn();
    commands.entity(enemy_entity).despawn();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完全沒有物理引擎，單純距離小於 30 就消失。但就算這麼陽春，打掉第一架敵機的瞬間還是很讚。&lt;/p&gt;

&lt;h2 id=&quot;part-2da7f3c6269d5783&quot;&gt;自動清理&lt;/h2&gt;

&lt;p&gt;最後一件必須要處理的是，子彈飛出畫面、敵人掉下去，都要刪掉。不然遊戲跑久了會 lag。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;if transform.translation.y &amp;gt; WINDOW_HEIGHT / 2.0 + 100.0
    || transform.translation.y &amp;lt; -WINDOW_HEIGHT / 2.0 - 100.0 {
    commands.entity(entity).despawn();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;記得把這段加上去，不然最後會卡QQ&lt;/p&gt;

&lt;h2 id=&quot;part-6542acf8e35&quot;&gt;小結&lt;/h2&gt;

&lt;p&gt;總之，這是一個運用 Bevy 就能寫出來的一個遊戲，雖然很簡單，但是應該可以有很多可能性，例如可以再加上特效、聲音，可能還可以加上計分系統。&lt;/p&gt;

&lt;p&gt;這篇文章只是我用 Bevy 寫遊戲的一個小實驗。其實我還在寫一個完整的 Bevy 系列文，會一步一步帶大家從 ECS 入門，到做出一個 Rogue-lite 小遊戲。
如果你對 Rust 遊戲開發有興趣，歡迎看一下&lt;a href=&quot;https://ithelp.ithome.com.tw/users/20120293/ironman/8770&quot;&gt;鐵人賽系列&lt;/a&gt;&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sat, 20 Sep 2025 02:24:24 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-bevy-Raiden.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 1 minutes</category>
    </item>
    <item>
      <title>Drizzle v.s Prisma</title>
      <link>https://railquill.vercel.app/drizzle-v-s-prisma.html</link>
      <description>比較 Prisma 跟 Drizzle 兩個 ORM 的一些差異。</description>
      <content:encoded><![CDATA[
        &lt;p&gt;目前的 JavaScript 的生態圈中，有很多出色的 SQL ORM，這些 ORM 都是為了幫助開發者能夠有更好的開發體驗，而新的 &lt;a href=&quot;https://risingstars.js.org/2024/en&quot;&gt;2024 JavaScript Rising Stars&lt;/a&gt; 榜單出爐了，這篇文章將會來介紹 Prisma 跟 Drizzle 這兩個熱門的 ORM，並且比較兩者有什麼差異。&lt;/p&gt;

&lt;h2 id=&quot;part-2c5c0dcf4a5ebc39&quot;&gt;安裝比較&lt;/h2&gt;

&lt;p&gt;這篇文章將會以 Express 來做安裝 ORM 的比較，並且只以 JavaScript 而不是 TypeScript。&lt;/p&gt;

&lt;p&gt;一開始的 Express 專案是以最簡易的架構來安裝，現在 Express 的架構大概是這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;├── 📜 package-lock.json
├── 📜 package.json
└── 📂 src
    └── 📜 index.js
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在的 &lt;code&gt;index.js&lt;/code&gt; 這樣可以拿到 Hello World：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const express = require(&quot;express&quot;);
const app = express();

app.get(&quot;/&quot;, (req, res) =&amp;gt; {
  res.send(&quot;Hello World&quot;);
});

app.listen(3000, () =&amp;gt; {
  console.log(&quot;Server is running on port 3000&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;drizzle&quot;&gt;Drizzle&lt;/h3&gt;

&lt;p&gt;先從 Drizzle 的安裝開始，drizzle 支援許多資料庫，像是 PostgreSQL 和 MySQL 都有，這次會使用 PostgreSQL 的方式。&lt;/p&gt;

&lt;h4 id=&quot;1-drizzle-pg&quot;&gt;1. 安裝 drizzle 和 pg&lt;/h4&gt;

&lt;p&gt;這裡可以直接按照官網的方式來安裝：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npm i drizzle-orm pg
npm i -D drizzle-kit @types/pg
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;2&quot;&gt;2. 連接資料庫&lt;/h4&gt;

&lt;p&gt;接下來在專案中新增一個 &lt;code&gt;.env&lt;/code&gt; 的環境變數，裡面可以連接 PG 的 database，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;DATABASE_URL=postgresql://postgres:postgres@localhost:5432/drizzle_database
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安裝 dotenv 來處理環境變數：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npm i dotenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後使用 drizzle 連接 PG：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const express = require(&quot;express&quot;);
const app = express();
const dotenv = require(&quot;dotenv&quot;);
const { drizzle } = require(&quot;drizzle-orm/node-postgres&quot;);
const { Pool } = require(&quot;pg&quot;);
dotenv.config();

const pool = new Pool({
  connectionString: process.env.DATABASE_URL
});

const db = drizzle(pool);
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;3-table&quot;&gt;3. 新增 table&lt;/h4&gt;

&lt;p&gt;這裡的例子是從零開始，所以我們需要自己建立一個 schema，建議在 src 資料夾底下新增一個資料夾，命名為 &lt;code&gt;db&lt;/code&gt;，並新增一個檔案 &lt;code&gt;schema.ts&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const { integer, pgTable, varchar, text, timestamp } = require(&#39;drizzle-orm/pg-core&#39;);

const usersTable = pgTable(&#39;users&#39;, {
  id: integer().primaryKey().generatedAlwaysAsIdentity(),
  name: varchar({ length: 50 }).notNull(),
  age: integer().notNull(),
  email: varchar({ length: 255 }).notNull().unique(),
  created_at: timestamp().defaultNow(),
  address: varchar({ length: 255 }).notNull()
});

const postsTable = pgTable(&#39;posts&#39;, {
  id: integer().primaryKey().generatedAlwaysAsIdentity(),
  title: varchar({ length: 100 }).notNull(),
  content: text().notNull(),
  user_id: integer().references(() =&amp;gt; usersTable.id),
  created_at: timestamp().defaultNow(),
})

module.exports = {
  usersTable,
  postsTable
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這裡我們試著建立 users 和 posts 的資料表，如果要使用各種資料庫的型別，必須從 drizzle 裡面取得相關的 function，例如 integer，就要使用 &lt;code&gt;integer()&lt;/code&gt;。然後要設定關聯的話，例如 posts 跟 users 有關聯，可以在 postsTable 的 user_id 設定 &lt;code&gt;integer()&lt;/code&gt;，並使用它裡面的 `references()&lt;/p&gt;

&lt;h4 id=&quot;4-drizzle-config&quot;&gt;4. 設定 Drizzle config&lt;/h4&gt;

&lt;p&gt;設定完資料的 schema 之後，還需要讓 Drizzle 知道這個專案有哪些 schema，還有連結什麼資料庫，並且設定之後 migration 產生的檔案會產生在哪裡。&lt;/p&gt;

&lt;p&gt;所以我們需要在根目錄新增一個 &lt;code&gt;drizzle.config.js&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const dotenv = require(&quot;dotenv&quot;);
const { defineConfig } = require(&#39;drizzle-kit&#39;);

dotenv.config();

module.exports = defineConfig({
  out: &#39;./drizzle&#39;,
  schema: &#39;./src/db/schema.js&#39;,
  dialect: &#39;postgresql&#39;,
  dbCredentials: {
    url: process.env.DATABASE_URL
  }
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;5&quot;&gt;5. 更新資料庫&lt;/h4&gt;

&lt;p&gt;執行 generate 之後，就會在專案中建立一個 &lt;code&gt;drizzle&lt;/code&gt; 的資料夾，並且自動新增一些 sql 的檔案。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npx drizzle-kit generate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來需要透過 ORM 去更新 PG 資料庫：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npx drizzle-kit migrate
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來可以檢查 PG 資料庫，應該就可以看到資料庫新增 users 和 posts 的 table。&lt;/p&gt;

&lt;h3 id=&quot;prisma&quot;&gt;Prisma&lt;/h3&gt;

&lt;p&gt;Prisma 的部分，一樣是沿用 Drizzle 所使用的 Express 架構，或者是要重新建立一個也可以。&lt;/p&gt;

&lt;h4 id=&quot;1-prisma&quot;&gt;1. 安裝 Prisma&lt;/h4&gt;

&lt;p&gt;首先第一步，就是安裝 Prisma ORM：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npm install prisma @prisma/client
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這一步安裝，跟 Drizzle 不一樣的是，它會幫專案自動產生 &lt;code&gt;.env&lt;/code&gt; 和 prisma 的資料夾，而且裡面自動產生一個 &lt;code&gt;schema.prisma&lt;/code&gt; 的特殊檔案，並且預設是連結 postgresql 的設定，當然 Prisma 也提供了很多不同資料庫，有興趣的朋友可以再考慮切換。&lt;/p&gt;

&lt;h4 id=&quot;2&quot;&gt;2. 連接資料庫&lt;/h4&gt;

&lt;p&gt;接下來要連接資料庫，就在 Prisma 幫我們產生的 &lt;code&gt;.env&lt;/code&gt; 環境變數中接上資料庫位置。&lt;/p&gt;

&lt;h4 id=&quot;3-table&quot;&gt;3. 新增 table&lt;/h4&gt;

&lt;p&gt;前面的步驟在 prisma 的資料夾中，產生了一個 &lt;code&gt;schema.prisma&lt;/code&gt; 的檔案，這個檔案如名稱所示，就是拿來放資料庫的 schema，如果是按照前面的 users 和 posts 兩個 table 架構的話，會是這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;model posts {
  id         Int       @id @default(autoincrement())
  title      String    @db.VarChar(100)
  content    String
  user_id    Int?
  created_at DateTime? @default(now()) @db.Timestamp(6)
  users      users?    @relation(fields: [user_id], references: [id], onDelete: NoAction, onUpdate: NoAction, map: &quot;posts_user_id_users_id_fk&quot;)
}

model users {
  id         Int       @id @default(autoincrement())
  name       String    @db.VarChar(50)
  age        Int
  email      String    @unique(map: &quot;users_email_unique&quot;) @db.VarChar(255)
  created_at DateTime? @default(now()) @db.Timestamp(6)
  address    String    @db.VarChar(255)
  posts      posts[]
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&quot;4&quot;&gt;4. 更新資料庫&lt;/h4&gt;

&lt;p&gt;建立完 table 的架構之後，要執行 migrate 讓本地的資料庫做更新：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npx prisma migrate dev --name &quot;init&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;執行完之後，就會在 prisma 資料夾裡面產生 migrations 的紀錄，並且 postgresql 的資料庫也會新增相對應的 table。&lt;/p&gt;

&lt;h2 id=&quot;api&quot;&gt;實作 API&lt;/h2&gt;

&lt;p&gt;以上是安裝兩種 ORM 的差別，接下來我們來試著在 Express 上實作 API，做新增跟讀取 USER 的功能。
首先我們先看 Drizzle 的做法：&lt;/p&gt;

&lt;h3 id=&quot;drizzle&quot;&gt;Drizzle&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;// index.js

const { usersTable, postsTable } = require(&quot;./db/schema&quot;);

app.use(express.json());

app.get(&quot;/users&quot;, async (req, res) =&amp;gt; {
  const users = await db.select().from(usersTable);
  res.json(users);
});

app.post(&quot;/users&quot;, async (req, res) =&amp;gt; {
  const user = await db.insert(usersTable).values({
    name: req.body.name,
    age: req.body.age,
    email: req.body.email,
    address: req.body.address
  });
  res.status(201).json({ message: &quot;新增成功&quot; });
});

app.post(&quot;/posts&quot;, async (req, res) =&amp;gt; {
  const post = await db.insert(postsTable).values({
    title: req.body.title,
    content: req.body.content,
    user_id: req.body.user_id
  });
  res.status(201).json({ message: &quot;新增成功&quot; });
});

app.get(&quot;/posts&quot;, async (req, res) =&amp;gt; {
  const posts = await db.select().from(postsTable);
  res.json(posts);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;記得要使用 &lt;code&gt;express.json()&lt;/code&gt; 不然會沒辦法正確新增 JSON 的格式。
接下來沒意外的話應該就可以正常使用 user 和 posts 的新增和讀取 API 了。&lt;/p&gt;

&lt;h3 id=&quot;prisma&quot;&gt;Prisma&lt;/h3&gt;

&lt;p&gt;Prisma ORM 的方式，會需要透過 PrismaClient 來建立一個實例，並且透過它在我們設定的架構下，分別去做資料庫的操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;javascript&quot;&gt;const express = require(&quot;express&quot;);
const app = express();
const dotenv = require(&quot;dotenv&quot;);
dotenv.config();
const { PrismaClient } = require(&quot;@prisma/client&quot;);

const prisma = new PrismaClient();

app.use(express.json());

app.get(&quot;/users&quot;, async (req, res) =&amp;gt; {
  const users = await prisma.users.findMany();
  res.json(users);
});

app.post(&quot;/users&quot;, async (req, res) =&amp;gt; {
  const user = await prisma.users.create({
    data: {
      name: req.body.name,
      age: req.body.age,
      email: req.body.email,
      address: req.body.address
    }
  });
  res.status(201).json({ message: &quot;User created&quot; });
});

app.get(&quot;/posts&quot;, async (req, res) =&amp;gt; {
  const posts = await prisma.posts.findMany();
  res.json(posts);
});

app.post(&quot;/posts&quot;, async (req, res) =&amp;gt; {
  const post = await prisma.posts.create({
    data: {
      title: req.body.title,
      content: req.body.content,
      user_id: req.body.user_id
    }
  });
  res.status(201).json({ message: &quot;Post created&quot; });
});

app.listen(3000, () =&amp;gt; {
  console.log(&quot;Server is running on port 3000&quot;);
});
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-6542d156155&quot;&gt;比較&lt;/h2&gt;

&lt;h3 id=&quot;part-6542aa814e9&quot;&gt;安裝&lt;/h3&gt;

&lt;p&gt;安裝以及設定的部分，在 Prisma 比較簡單，只要下一個指令，就會自動在專案中自動建立一些檔案，例如 schema 以及相關的設定檔；相反 Drizzle 就稍微比較麻煩一點。&lt;/p&gt;

&lt;h3 id=&quot;schema&quot;&gt;schema&lt;/h3&gt;

&lt;p&gt;兩邊在 schema 的使用各有優缺點：&lt;/p&gt;

&lt;h4 id=&quot;prisma&quot;&gt;Prisma&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;優點：有一個獨有的檔案來管理，視覺上方便閱讀，對於 table 的架構一目了然，型別以及是否必填也蠻清楚。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/P5c3cHr.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缺點：不太好撰寫，如果是想要在 &lt;code&gt;schema.prisma&lt;/code&gt; 手寫的話有點學習成本，需要按照 Prisma 特有的語法去寫。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;drizzle&quot;&gt;Drizzle&lt;/h4&gt;

&lt;ul&gt;
&lt;li&gt;優點：寫法就是一般的 JS，而且跟原本的 SQL 非常相似，學習成本比較低。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/boVP7JB.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;缺點： 架構上跟 Prisma 相比，比較沒這麼好閱讀，但熟悉 JS 的開發者應該也能很快上手。&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;part-6542b16cbc8&quot;&gt;操作&lt;/h3&gt;

&lt;p&gt;在操作上，Drizzle 跟原本 SQL 語法非常類似，這對於熟悉 SQL 的開發者來說，是一個巨大的優勢。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/dOXHmhL.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;Prisma 有自己的方法，所以勢必要學習一下，可能會有一些陣痛期。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/q2sayGl.png&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-6542fd4e95a&quot;&gt;結論&lt;/h2&gt;

&lt;p&gt;以目前的 JS 生態來說，兩個 ORM 都是很棒的工具。Prisma 目前在 GitHub 擁有 40.7k 的星星數，而 Drizzle 則是擁有 25.7k 的星星數。
而且目前兩者的下載量明顯有一些差距，代表著 Prisma 是比較熱門的選項。
&lt;img src=&quot;https://i.imgur.com/Lf95O0R.png&quot; alt=&quot;npm trends&quot;&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;圖片來源 npm trends&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;但 Drizzle 其實是非常年輕的 ORM，根據 &lt;a href=&quot;https://orm.drizzle.team/docs/latest-releases&quot;&gt;Drizzle 官網&lt;/a&gt;頁面顯示，最早是在 2022 年 7 月推出。在這之前的 &lt;a href=&quot;https://risingstars.js.org/2024/en&quot;&gt;JavaScript Rising Stars&lt;/a&gt; 報告中，都是 Prisma 在這個榜單上，Drizzle 出現之後就看似取代了 Prisma 了，是一個可以觀察並且參考的部分。&lt;/p&gt;

&lt;p&gt;在開發選擇的情境上，如果團隊比較熟悉 SQL 的話，那麼選擇 Drizzle 是一個比較好的選擇，如果說想要有比較完整的工具鏈，那麼可以考慮選擇 Prisma。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Thu, 19 Dec 2024 10:55:45 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/drizzle-v-s-prisma.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 5 minutes</category>
    </item>
    <item>
      <title>從手把手環境設定到建立第一個 Flutter 專案</title>
      <link>https://railquill.vercel.app/flutter.html</link>
      <description>帶你手把手把 Flutter 的環境設定弄好！</description>
      <content:encoded><![CDATA[
        &lt;p&gt;環境設定永遠是開發者一開始遇到的新人殺手，尤其是當你下定決定想學一項技術，但在環境設定就卡關，然後...就沒有然後了😭。Flutter 的環境設定算有點麻煩，但希望本篇文章可以幫助你打贏第一個關卡。然後由於我手上只有 macOS，所以這篇文章會以 macOS 的用戶視角來進行環境安裝。&lt;/p&gt;

&lt;h2 id=&quot;part-2e3d2e4d10913e3a&quot;&gt;選擇環境&lt;/h2&gt;

&lt;p&gt;進到&lt;a href=&quot;https://docs.flutter.dev/get-started/install&quot;&gt;官網&lt;/a&gt;之後，可以選擇你的開發系統，並按照官方文件來一步一步完成環境設定的前置作業，這裡選擇 macOS 來示範。
&lt;img src=&quot;https://i.imgur.com/2CWMTTi.png&quot; alt=&quot;20240914001628&quot;&gt;&lt;/p&gt;

&lt;p&gt;接下來會問你主要想開發什麼類型的 App，由於 Flutter 是一個可以跨平台開發的框架，不管是 iOS 還是 Android，甚至是 Desktop App 還是 Web 都能勝任。不過我們的目標主要是要開發 mobile app，所以這裡我們選擇 iOS 或是 Android 都可以，這裡我們先選擇 iOS。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ot17JUJ.png&quot; alt=&quot;20240914001714&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-28fef6f2d54380ae&quot;&gt;安裝必要的開發工具&lt;/h2&gt;

&lt;p&gt;進到 iOS 的設定頁面，會先看到密密麻麻的一堆文字，但不用擔心，接下來一步一步帶你設定。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;首先想要開發 iOS app，那麼就必須要安裝必要的 Xcode（這是一個在 App Store 上評分超低分，而且又超級肥的工具，但只能用它），後面會需要做一些設定。
&lt;img src=&quot;https://i.imgur.com/fZ9YXQD.png&quot; alt=&quot;20240914001743&quot;&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;理論上安裝完這個東西你還可以順便得到 Git，但我想一個合格的工程師電腦上應該都有 Git 吧？&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;接下來如果你的電腦是 Apple silicon，舉凡 M1、M2 等等的晶片，那麼你要在終端機執行以下的指令：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;sudo softwareupdate --install-rosetta --agree-to-license
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;flutter-sdk&quot;&gt;安裝 Flutter SDK&lt;/h2&gt;

&lt;p&gt;進到 iOS 的設定頁面，直接畫面往下滑到 &lt;code&gt;Install the Flutter SDK&lt;/code&gt; 的部分，這裡有兩個選擇：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use VS Code to install&lt;/li&gt;
&lt;li&gt;Download and install&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;那麼這兩個有什麼差別呢？主要是看你之後用什麼方式開發，並且用什麼來模擬。如果是選擇 VSCode，未來都可以在 VSCode 上面就好；反之如果你想要另外開終端機來輸入指令的話，那就可以選擇 Download and install。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;下載 SDK&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;我是建議直接下載 SDK，然後再視情況安裝 VSCode Extension。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/fGeZEvj.png&quot; alt=&quot;20240914001852&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果是 Intel 晶片的就選 inter Processor；反之如果是 Apple Silicon 的就選另一個。&lt;/p&gt;

&lt;p&gt;下載 zip 檔案之後解壓縮，會得到一個 &lt;code&gt;flutter&lt;/code&gt; 的資料夾，裡面就是 Flutter 的 SDK，然後在你的根目錄建立一個 &lt;code&gt;development&lt;/code&gt; 的資料夾，接著把整包 &lt;code&gt;flutter&lt;/code&gt; 資料夾丟進去。所以你的架構應該會是：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/development/flutter/
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;加入 Flutter 到 PATH&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;移動到你的根目錄，打開你的終端機，並輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cd ~/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;檢查看有沒有 &lt;code&gt;.zshenv&lt;/code&gt; 這個檔案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;ls -a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;沒有的話就自己新增一個。接下來用你習慣的編輯器打開它，我是蠻推薦直接用 vim 來直接新增或者是編輯：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;vim .zshenv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後把這一段直接複製貼上：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;export PATH=$HOME/development/flutter/bin:$PATH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;路徑就是剛剛在根目錄新增的 &lt;code&gt;/development/flutter/&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;存檔之後最好重開終端機，然後在終端機輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;which flutter
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;應該可以看到類似的東西：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sGy5bYM.png&quot; alt=&quot;20240914001920&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果沒看到或是顯示錯誤，也不用擔心，代表可能是路徑錯誤，再仔細看一下有沒有打錯字。&lt;/p&gt;

&lt;p&gt;最後在終端機輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter doctor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ogMyCcD.png&quot; alt=&quot;20240914001940&quot;&gt;&lt;/p&gt;

&lt;p&gt;那麼你的 Flutter SDK 設定大致上就完成了👏。&lt;/p&gt;

&lt;h2 id=&quot;xcode&quot;&gt;設定 Xcode&lt;/h2&gt;

&lt;p&gt;前面提到想要開發 iOS 必定要有 Xcode，接下來打開你的 App Store，搜尋 Xcode。&lt;/p&gt;

&lt;p&gt;安裝完 Xcode 之後，在終端機輸入指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;sudo sh -c &#39;xcode-select -s /Applications/Xcode.app/Contents/Developer &amp;amp;&amp;amp; xcodebuild -runFirstLaunch&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;再次輸入指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;sudo xcodebuild -license
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這是一段協議書，需要你看完並同意，沒問題的話就直接輸入 &lt;code&gt;agree&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;part-40f050023a78a025&quot;&gt;模擬工具設定&lt;/h2&gt;

&lt;p&gt;在開發的過程中，我們需要畫面來查看是否正確，或者是操作上有沒有問題。&lt;/p&gt;

&lt;p&gt;Xcode 提供了 Simulator 這個工具，可以讓你在 Mac 上直接模擬一台 iPhone 甚至是 iPad。&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;安裝 iOS Simulator，在終端機輸入指令：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;xcodebuild -downloadPlatform iOS
&lt;/code&gt;&lt;/pre&gt;

&lt;ol&gt;
&lt;li&gt;打開 Simulator：&lt;/li&gt;
&lt;/ol&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;open -a Simulator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以看到一台 iPhone 的畫面呈現在你的電腦上。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/K02nq2q.png&quot; alt=&quot;20240914002011&quot;&gt;&lt;/p&gt;

&lt;p&gt;恭喜你，你的 Flutter 現在就可以開發 iOS app 了。&lt;/p&gt;

&lt;p&gt;經歷完環境安裝的艱難過程後，終於可以開始來建立我們第一個 Flutter 專案了，這篇文章將會介紹幾個方式來建立專案。&lt;/p&gt;

&lt;h2 id=&quot;1-commend-line&quot;&gt;1. 使用 Commend Line 來建立&lt;/h2&gt;

&lt;p&gt;首先打開終端機，然後在你想要建立專案的位置，例如 desktop，輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;mkdir first_flutter &amp;amp;&amp;amp; cd &quot;$_&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這段指令會直接新增一個叫做 &lt;code&gt;first_flutter&lt;/code&gt; 的資料夾，並移動進該 &lt;code&gt;first_flutter&lt;/code&gt; 中。&lt;/p&gt;

&lt;p&gt;然後接下來介紹一下 Flutter 的指令有哪些。&lt;/p&gt;

&lt;p&gt;如果你一開始什麼都不知道的話，那麼可以輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter -h
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這段指令就是 &lt;code&gt;flutter --help&lt;/code&gt; 的簡易版，想成是要進入 Flutter 的遊客中心，裡面會列出基本的資訊，這是一段非常實用的指令，可以記一下。&lt;/p&gt;

&lt;p&gt;如果想確認一下現在安裝在你電腦中的 Flutter 版本是哪一版的話，就輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter --version
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;例如可以看到我現在安裝的 Flutter 版本是 3.22.3，Dart 的版本是 3.4.4。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VHAgDon.png&quot; alt=&quot;20240914002418&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後如果你輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這一段不是 &lt;code&gt;flutter --version&lt;/code&gt; 的簡易版喔，而是代表 Flutter “詳細”的選項。&lt;/p&gt;

&lt;p&gt;如果你輸入 &lt;code&gt;flutter -v&lt;/code&gt; 的話，應該可以發現跟 &lt;code&gt;flutter -h&lt;/code&gt; 有點像，但是解釋的更詳細。在目前的版本中，&lt;code&gt;flutter -v&lt;/code&gt; 就等同於 &lt;code&gt;flutter --help -v&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;所以如果你想得到某些指令更詳細的資訊的話，就在最後面加上 &lt;code&gt;-v&lt;/code&gt;，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter --version -v
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;就可以顯示更詳細的 Flutter 版本資訊了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/rHC7DBt.png&quot; alt=&quot;20240914002444&quot;&gt;&lt;/p&gt;

&lt;p&gt;稍微介紹了一下 Flutter 的指令之後，你可能有看到並知道怎麼輸入建立專案的指令了，沒錯，輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter create hello_world
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;後面的 &lt;code&gt;hello_world&lt;/code&gt; 你可以帶入任何的名稱，不過最好是使用 Snake case，因為這個是慣例。&lt;/p&gt;

&lt;p&gt;沒問題的話，就可以看到如同下面圖片的資訊：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RODR486.png&quot; alt=&quot;20240914002505&quot;&gt;&lt;/p&gt;

&lt;p&gt;會跟你說接下來你應該移動到新建的專案資料夾中，接著執行 &lt;code&gt;flutter run&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但我們先不要急，先移動到該新建的專案資料夾中，然後使用你慣用的編輯器打開資料夾，這裡會使用 VSCode 來示範。&lt;/p&gt;

&lt;p&gt;使用 VSCode 開啟專案之後，接下來在 Extensions 搜尋 flutter，認明這個 Flutter 官方的 Extension。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/B1V2Qig.png&quot; alt=&quot;20240914002531&quot;&gt;&lt;/p&gt;

&lt;p&gt;或者是直接點&lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter&quot;&gt;這裡&lt;/a&gt;下載。&lt;/p&gt;

&lt;p&gt;接下來要來介紹第二種建立 Flutter 專案的方法。&lt;/p&gt;

&lt;h2 id=&quot;vscode&quot;&gt;使用 VSCode 建立專案&lt;/h2&gt;

&lt;p&gt;這個方法適合不喜歡開太多東西，只想開一個 VSCode 就搞定的人。&lt;/p&gt;

&lt;p&gt;那麼一樣先建立一個空的資料夾，然後進去該新建的資料夾，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;mkdir first_flutter &amp;amp;&amp;amp; cd &quot;$_&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後用 VSCode 打開這個新增的資料夾，接下來鍵盤指令 combo，按下 &lt;code&gt;command&lt;/code&gt; + &lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;p&lt;/code&gt;，如果是 Windows 的用戶應該會是 &lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;p&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;會在你的 VSCode 跳出一個 Command Palette。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4UT8v5c.png&quot; alt=&quot;20240914002558&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後輸入 flutter，然後選擇 &lt;code&gt;Flutter: New Project&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5fj4fLE.png&quot; alt=&quot;20240914002615&quot;&gt;&lt;/p&gt;

&lt;p&gt;接下來會跳出：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jmygdFd.png&quot; alt=&quot;20240914002631&quot;&gt;&lt;/p&gt;

&lt;p&gt;這裡有幾個 Template 可以選擇，沒特別要求的話，就選 Application 就好，這個就等同於指令 flutter create 建立新專案。&lt;/p&gt;

&lt;p&gt;建立完你的 VSCode 就會跳出一個提示：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/n7AckkG.png&quot; alt=&quot;20240914002711&quot;&gt;&lt;/p&gt;

&lt;p&gt;跟你說 Flutter 專案已經建立完成，可以直接按 F5 就可以跑囉！&lt;/p&gt;

&lt;h2 id=&quot;flutter-app&quot;&gt;執行你的第一個 Flutter App&lt;/h2&gt;

&lt;p&gt;接下來介紹一下要怎麼執行 Flutter App。&lt;/p&gt;

&lt;h2 id=&quot;1-vscode&quot;&gt;1. 在 VSCode 上執行&lt;/h2&gt;

&lt;p&gt;第一種方法先介紹如何在 VSCode 上執行模擬器。&lt;/p&gt;

&lt;p&gt;先使用 VSCode 打開你的專案，應該會看到如同下圖的畫面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/XLTgKRL.png&quot; alt=&quot;20240914003051&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後用 VSCode 打開這個新增的資料夾，接下來鍵盤指令 combo，按下 &lt;code&gt;command&lt;/code&gt; + &lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;p&lt;/code&gt;，如果是 Windows 的用戶應該會是 &lt;code&gt;ctrl&lt;/code&gt; + &lt;code&gt;shift&lt;/code&gt; + &lt;code&gt;p&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;會在你的 VSCode 跳出一個 Command Palette。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hupC5W3.png&quot; alt=&quot;20240914003122&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後輸入 flutter，然後選擇 &lt;code&gt;Launch Emulator&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/VhsA0dR.png&quot; alt=&quot;20240914003155&quot;&gt;&lt;/p&gt;

&lt;p&gt;接下來應該會跳出一些模擬器的選擇：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/XbEuNov.png&quot; alt=&quot;20240914003215&quot;&gt;&lt;/p&gt;

&lt;p&gt;例如有 iOS 的跟 android 的，這裡先示範 iOS 的。&lt;/p&gt;

&lt;p&gt;當你選完 iOS 之後，就會跳出一個 Simulator，可以看到一個 iPhone 的畫面在你的電腦上，不過還沒有真正執行你的專案中的程式碼。&lt;/p&gt;

&lt;p&gt;現在請你的 VSCode 上面，並按照兩個步驟點擊。可以參考下圖中的範例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/6ku3khZ.png&quot; alt=&quot;20240914003246&quot;&gt;&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;找到 &lt;code&gt;lib&lt;/code&gt; 資料夾中的 &lt;code&gt;main.dart&lt;/code&gt; 檔案。&lt;/li&gt;
&lt;li&gt;在 &lt;code&gt;main()&lt;/code&gt; 的上方，可以看到有一排文字：&lt;code&gt;Run | Debug | Profile&lt;/code&gt;。&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;如果沒看到這排文字，可能代表你沒安裝 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=Dart-Code.flutter&quot;&gt;Flutter&lt;/a&gt; 的官方 Extension。可以試著再安裝一次，或者重新開啟 VSCode。&lt;/p&gt;

&lt;p&gt;然後點擊 &lt;code&gt;Run&lt;/code&gt;，就可以看到 VSCode 右下角正在執行中：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/MkG5xk0.png&quot; alt=&quot;20240914003316&quot;&gt;&lt;/p&gt;

&lt;p&gt;成功運作的話，可以看到 VSCode 多了一個控制列。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3EJKDiQ.png&quot; alt=&quot;20240914003333&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後你的 iOS Simulator 畫面應該會是這樣：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TRIRn0N.png&quot; alt=&quot;20240914003345&quot;&gt;&lt;/p&gt;

&lt;p&gt;接下來我們試著改變一下程式碼。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;main.dart&lt;/code&gt; 這個檔案，往下滑找到：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;dart!&quot;&gt;&#39;You have pushed the button this many times:&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這一段就是在畫面上的顯示的文字，我們隨便改一下之後，畫面會隨著你修改之後馬上 Hot Reload 更新。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Aq2TTRk.png&quot; alt=&quot;20240914003412&quot;&gt;&lt;/p&gt;

&lt;p&gt;有時候可能會遇到沒有更新的情況，沒關係。直接在 VSCode 的那個控制列，點擊 ⚡️ 的按鈕，這個是 Save and Hot Reload 的功能，這樣你的畫面應該就會按照你修改的更新了。&lt;/p&gt;

&lt;h2 id=&quot;part-d978f4e315e7e7d1&quot;&gt;在終端機上執行&lt;/h2&gt;

&lt;p&gt;前面示範了如何在 VSCode 執行 Flutter 的專案，並且如何即時更新，接下來來示範如何在終端機做這些動作。&lt;/p&gt;

&lt;p&gt;首先打開你的終端機，如果你直接執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;應該會顯示以下的畫面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/h0gsxjU.png&quot; alt=&quot;20240914003436&quot;&gt;&lt;/p&gt;

&lt;p&gt;這是代表我們並沒有連結任何的裝置，或是模擬器。&lt;/p&gt;

&lt;p&gt;如果我們想確認一下現在 Flutter 有沒有連結任何裝置或模擬器，可以執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter devices
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;應該會看到類似以下的訊息：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/MmVQRQW.png&quot; alt=&quot;20240914003457&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果有連結的話，會顯示在上面，但如果沒有，他提示你說，可以執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter emulators
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;執行完會跟你說，現在有哪些模擬器可以使用。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Vio1JAi.png&quot; alt=&quot;20240914003516&quot;&gt;&lt;/p&gt;

&lt;p&gt;並且提示你目前你如果要執行模擬器，可以執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter emulators --launch &amp;lt;emulator id&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;以我目前的狀況，我想打開 iOS Simulator 就是輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter emulators --launch apple_ios_simulator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果這裡都沒出現任何裝置的話，那麼他也提示你，可以輸入指令自己新增：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter emulators --create [--name xyz]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;通常只要模擬器已經開啟，那麼就可以直接執行 Flutter 專案了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;flutter run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你的終端機會出現這樣的畫面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/BcavgsG.png&quot; alt=&quot;20240914003539&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後如果我們修改一下程式碼，可以發現可能沒辦法即時更新畫面。&lt;/p&gt;

&lt;p&gt;沒關係，終端機有提示我們可以執行 &lt;code&gt;r&lt;/code&gt; 來做 Hot reload，也可以做到更新程式碼的動作。&lt;/p&gt;

&lt;p&gt;以上就是如何透過 VSCode 和終端機來執行 Flutter 專案的流程，各位可以選擇喜歡並且順手的方式。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sat, 14 Sep 2024 00:08:54 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/flutter.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 4 minutes</category>
    </item>
    <item>
      <title>Rust 從零開始網頁爬蟲(2024 Hello World)</title>
      <link>https://railquill.vercel.app/rust-2024-hello-world.html</link>
      <description>本篇文章是 2024 Hello World Dev Conference 工作坊的實作流程，可以搭配 Github repohttps://github.com/bucky0112/scrapingrust 一起使用。

 Rust 簡介
Rust 是一個近年來引起非常多討論的程式語言，因為效能出色，並且安全性...</description>
      <content:encoded><![CDATA[
        &lt;p&gt;本篇文章是 2024 Hello World Dev Conference 工作坊的實作流程，可以搭配 &lt;a href=&quot;https://github.com/bucky0112/scraping_rust&quot;&gt;Github repo&lt;/a&gt; 一起使用。&lt;/p&gt;

&lt;h2 id=&quot;rust&quot;&gt;Rust 簡介&lt;/h2&gt;

&lt;p&gt;Rust 是一個近年來引起非常多討論的程式語言，因為效能出色，並且安全性極佳，寫起來非常有趣，在每一年的 Stackoverflow 調查中已經連續蟬聯多年的最受歡迎程式語言（most-admired programming language），可以參考今年 2024 的&lt;a href=&quot;https://survey.stackoverflow.co/2024/technology/#admired-and-desired&quot;&gt;調查&lt;/a&gt;。也因為討論度很高，並且很多國際知名企業也紛紛投入使用，可以感受到似乎引領了一股風潮，好像什麼都要用 Rust 來改寫原本的產品，或者是出現以 Rust 開發的新東西。&lt;/p&gt;

&lt;h2 id=&quot;rust&quot;&gt;安裝 Rust&lt;/h2&gt;

&lt;p&gt;要安裝 Rust 非常簡單，只要進到&lt;a href=&quot;https://www.rust-lang.org/zh-TW/&quot;&gt;官網&lt;/a&gt;，然後按下“立即開始”的按鈕，就會偵測你目前電腦的系統，並給你安裝的建議與說明。像是我的電腦是 macOS 系統，所以只要按照指示，在終端機執行指令，就可以開始安裝。&lt;/p&gt;

&lt;p&gt;安裝 Rust 這個步驟主要會安裝兩個東西，分別是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Rustup&lt;/li&gt;
&lt;li&gt;Cargo&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Rustup 是 Rust 的安裝與版本管理工具，而 Cargo 則是 Rust 的建置與套件管理工具。&lt;/p&gt;

&lt;p&gt;如果想確認是否安裝成功，可以在終端機下指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;rustc -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;或者是：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cargo -V
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這兩個都能檢查目前安裝的版本（截至目前為止的版本為 1.81.0），例如下圖：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3tIP2Jq.png&quot; alt=&quot;20240913005124&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;Hello World，建立專案&lt;/h2&gt;

&lt;p&gt;既然安裝好了，不免俗的讓我們來做一個 Hello World，這裡會直接使用 Cargo 來建立一個 Rust 專案，請在終端機執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cargo new demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這段指令代表要使用 Cargo 來建立一個名稱 &lt;code&gt;demo&lt;/code&gt; 的專案，當然名稱可以自由命名。然後進入到該專案之後，並使用習慣的編輯器打開，例如 VSCode。&lt;/p&gt;

&lt;h3 id=&quot;vscode&quot;&gt;建議 VSCode 套件&lt;/h3&gt;

&lt;p&gt;如果是習慣用 VSCode 的人，強烈建議 &lt;a href=&quot;https://marketplace.visualstudio.com/items?itemName=rust-lang.rust-analyzer&quot;&gt;rust-analyzer&lt;/a&gt; 這個套件。在開發中可以有一些提示，或者是錯誤的提醒。&lt;/p&gt;

&lt;p&gt;現在你應該使用編輯器打開專案了，並且可以看到專案的架構：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;.
├── src
│   └── main.rs
├── target
├── .gitignore
├── Cargo.lock
└── Cargo.toml
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整個專案最主要的檔案是在 &lt;code&gt;src&lt;/code&gt; 底下的 &lt;code&gt;main.rs&lt;/code&gt;，它是 Rust 專案的 entrypoint，任何邏輯都會經由這裡來發動執行，那麼我們來看看 &lt;code&gt;main.rs&lt;/code&gt; 這個檔案。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;fn main() {
    println!(&quot;Hello, world!&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到建立專案已經幫我們處理好 Hello World 了，但是這個 &lt;code&gt;println!()&lt;/code&gt; 是什麼？&lt;/p&gt;

&lt;p&gt;以目的來說，他可以幫我們印出 Hello World，雖然看起來很像是一個函式，但在 Rust 中其實不是函式，而是一個巨集（Marco），可以先大概了解就可以。&lt;/p&gt;

&lt;h3 id=&quot;part-2c1204f93c6ace21&quot;&gt;執行專案&lt;/h3&gt;

&lt;p&gt;在 Cargo 專案中，要執行並且運作程式碼，可以在終端機下指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cargo run
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這一段指令會編譯並且執行目前的程式碼，所以可以在終端機看到 &lt;code&gt;Hello World&lt;/code&gt; 的結果。&lt;/p&gt;

&lt;h2 id=&quot;part-2ea806877f2aa35a&quot;&gt;開始爬蟲&lt;/h2&gt;

&lt;p&gt;在開始之前，需要先安裝這個專案需要用的套件。&lt;/p&gt;

&lt;h3 id=&quot;part-8da8f8589c6df2b2&quot;&gt;套件的搜尋&lt;/h3&gt;

&lt;p&gt;如果是熟悉網頁開發的朋友，大概都會知道有 NPM 這個東西，而 Rust 也有一個類似 NPM 的網站，那就是 &lt;a href=&quot;https://crates.io/&quot;&gt;crates.io&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/w0EM3SF.png&quot; alt=&quot;20240913005147&quot;&gt;&lt;/p&gt;

&lt;p&gt;我們需要安裝這些套件：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/tokio&quot;&gt;tokio&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/reqwest&quot;&gt;reqwest&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/scraper&quot;&gt;scraper&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;tokio 主要是處理非同步的操作；reqwest 是處理 HTTP 請求；scraper 則是處理網頁元素的選擇。&lt;/p&gt;

&lt;h3 id=&quot;part-708b4c5e64bc6729&quot;&gt;套件安裝的方式&lt;/h3&gt;

&lt;p&gt;套件安裝的方式有分成在終端機下指令安裝，和在專案中的 &lt;code&gt;Cargo.toml&lt;/code&gt; 手動輸入。以 tokio 為例，可以在右邊的 &lt;strong&gt;Install&lt;/strong&gt; 區塊看到安裝方式。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/jQNPm5Q.png&quot; alt=&quot;20240913005454&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一種方式是在終端機下指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cargo add tokio
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二種方式可以打開 &lt;code&gt;Cargo.toml&lt;/code&gt; 這個檔案，然後在 &lt;code&gt;[dependencies]&lt;/code&gt; 底下輸入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml!&quot;&gt;tokio = &quot;1.40.0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;tokio&quot;&gt;安裝 tokio 需要注意的地方&lt;/h3&gt;

&lt;p&gt;由於 crates 大都預設是基本的安裝，所以當需要開啟某些功能，還需要開啟設定，安裝的方式可以這樣做：&lt;/p&gt;

&lt;p&gt;第一種在終端機下指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cargo add tokio -F full
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;第二種方式也可以透過 &lt;code&gt;Cargo.toml&lt;/code&gt; 來安裝：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml!&quot;&gt;tokio = { version = &quot;1.40.0&quot;, features = [&quot;full&quot;] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果是經由 &lt;code&gt;Cargo.toml&lt;/code&gt; 來安裝的話，還需要在終端機下指令來進行編譯：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cargo build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;目前的 &lt;code&gt;Cargo.toml&lt;/code&gt; 應該會是這樣：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Oi9WD2y.png&quot; alt=&quot;20240913005210&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-cc3a7ae4d4b902ac&quot;&gt;要進行爬蟲的資料來源&lt;/h2&gt;

&lt;p&gt;這次工作坊要進行的爬蟲練習來源是&lt;a href=&quot;https://books.toscrape.com/&quot;&gt;這個網站&lt;/a&gt;。這是一個專門練習爬蟲的網站。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9LeonzC.png&quot; alt=&quot;20240913005230&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-84aab2f83254d926&quot;&gt;試著取得網頁內容&lt;/h2&gt;

&lt;p&gt;接下來就可以寫一些程式碼，先試著連到這個網站並取得網頁內容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;use reqwest;       // 使用 reqwest

#[tokio::main]     // 在 main 標記使用 tokio 處理非同步
async fn main() {  // 在 main 前面加上 async
    let url = &quot;https://books.toscrape.com/&quot;; // 連結的 URL
    let response = reqwest::get(url).await.unwrap(); // 使用 get
    let body = response.text().await.unwrap(); // 將 response 轉成可辨識的文字

    println!(&quot;{}&quot;, body); // 印出 body
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後執行 &lt;code&gt;cargo run&lt;/code&gt;，應該會看到印出整個網頁的內容。&lt;/p&gt;

&lt;h2 id=&quot;html&quot;&gt;解析 HTML&lt;/h2&gt;

&lt;p&gt;確認網頁內容沒問題之後，就可以進行下一步來解析 HTML，這裡需要借助 scraper。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;use scraper::Html; // 使用 scraper 的 HTML 方法

// ...

let document = Html::parse_document(&amp;amp;body); // 解析 body

println!(&quot;{}&quot;, document);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這時候執行 &lt;code&gt;cargo run&lt;/code&gt; 之後，會發現到有錯誤。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/3G01s3z.png&quot; alt=&quot;20240913005245&quot;&gt;&lt;/p&gt;

&lt;p&gt;Cargo 會提供完整的錯誤提示，甚至會跟你說你應該怎麼做比較好，所以就可以按照它的建議在 &lt;code&gt;println!()&lt;/code&gt; 中的 &lt;code&gt;{}&lt;/code&gt; 改成 &lt;code&gt;{:?}&lt;/code&gt; 或者是 &lt;code&gt;{:#?}&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;可以改成以下幾種方式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;println!(&quot;{:?}&quot;, document); // debug 格式化

println!(&quot;{:#?}&quot;, document); // pretty-print 格式

println!(&quot;{}&quot;, document.html()); // 轉回字符串，就是轉回原來的格式
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-e84c99d59c7ac262&quot;&gt;決定抓取哪些資料&lt;/h2&gt;

&lt;p&gt;我們主要是要抓每本書的名稱以及價錢，打開開發者工具檢查 HTML 架構，可以發現這裡是用 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 來區分每本書，但我們需要更方便辨識的方法，也就是按照 &lt;code&gt;&amp;lt;li&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;article&amp;gt;&lt;/code&gt;，這裡有 class 可以辨識，也就是 &lt;code&gt;product_pod&lt;/code&gt;，這樣就可以去選取每一本獨立的書。&lt;/p&gt;

&lt;p&gt;當選擇完每本書之後，就要去抓取書的書名以及價錢，可以在 &lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt; 和 &lt;code&gt;.product_price&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/9d2KXjp.png&quot; alt=&quot;20240913005302&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-5df8ce0a942e77ae&quot;&gt;建立選取器&lt;/h2&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;use scraper::{Html, Selector};
// ...
let book_selector = Selector::parse(&quot;article.product_pod&quot;).unwrap();
let title_selector = Selector::parse(&quot;h3 a&quot;).unwrap();
let price_selector = Selector::parse(&quot;div.product_price .price_color&quot;).unwrap();
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-da3d97c51885cb4d&quot;&gt;使用迴圈撈取資料&lt;/h2&gt;

&lt;p&gt;接下來就可以使用迴圈來撈取資料：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;for book in document.select(&amp;amp;book_selector) {
    let title = book
        .select(&amp;amp;title_selector)
        .next()
        .unwrap()
        .text()
        .collect::&amp;lt;String&amp;gt;();
    let price = book
        .select(&amp;amp;price_selector)
        .next()
        .unwrap()
        .text()
        .collect::&amp;lt;String&amp;gt;();

    println!(&quot;書名: {}&quot;, title);
    println!(&quot;價格: {}&quot;, price);
    println!(&quot;---&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;執行 &lt;code&gt;cargo run&lt;/code&gt; 之後，這樣就可以把每本書的書名以及價格全部印出來。&lt;/p&gt;

&lt;h2 id=&quot;part-f8bb379b2d44a6da&quot;&gt;利用屬性取得完整書名&lt;/h2&gt;

&lt;p&gt;執行完之後雖然可以取得書名以及價格，但是應該可以發現有些書名並不是完整的書名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/U09lOci.png&quot; alt=&quot;20240913005317&quot;&gt;&lt;/p&gt;

&lt;p&gt;這是因為網站本身在處理書名時，可能是針對太長的書名有進行修改。沒關係，可以看一下 HTML 架構中是否有提供完整的書名。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/rYQZwJE.png&quot; alt=&quot;20240913005328&quot;&gt;&lt;/p&gt;

&lt;p&gt;我們發現在 &lt;code&gt;&amp;lt;h3&amp;gt;&lt;/code&gt; 中的 &lt;code&gt;&amp;lt;a&amp;gt;&lt;/code&gt; 有一個 &lt;code&gt;title&lt;/code&gt; 的屬性，所以就可以利用這個屬性去取得完整的書名。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;let title_element = book.select(&amp;amp;title_selector).next().unwrap();
        // 使用 title 屬性獲取完整書名
let title = title_element.value().attr(&quot;title&quot;).unwrap_or(&quot;Unknown Title&quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在再次執行 &lt;code&gt;cargo run&lt;/code&gt; 就可以取得完整的書名了。&lt;/p&gt;

&lt;h2 id=&quot;part-2e77907a852ede12&quot;&gt;錯誤處理&lt;/h2&gt;

&lt;p&gt;如果看現在的程式碼，應該可以發現有大量的 &lt;code&gt;unwrap()&lt;/code&gt;。其實這個是錯誤處理的方式之一，但是並不能算是非常好的作法，因為當有碰到錯誤的時候，在 &lt;code&gt;unwrap()&lt;/code&gt; 這裡就會立即終止所有程式，不會再繼續往下走了，如果是拿來開發初期可能很好用，但是還是要預想遇到錯誤會怎麼繼續往下跑你的程式碼。&lt;/p&gt;

&lt;p&gt;這裡就會用到 Rust 本身自帶的工具，從 &lt;code&gt;std&lt;/code&gt; 也就是 Rust 的 standard library 中使用 &lt;code&gt;Error&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;use std::error::Error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那麼要怎麼使用呢？&lt;/p&gt;

&lt;p&gt;首先會用到 &lt;code&gt;Result&lt;/code&gt; 這個 enum，它是一個這樣的結構：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;pub enum Result&amp;lt;T, E&amp;gt; {
    Ok( /* … */ ),
    Err( /* … */ ),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;原本應該也要使用關鍵字 &lt;code&gt;use&lt;/code&gt; 來使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;use std::result::Result;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;不過可能因為 &lt;code&gt;Result&lt;/code&gt; 是比較常用，所以就不需要特別使用 &lt;code&gt;use&lt;/code&gt; 來引入，而是可以直接用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;async fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
    // ...
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由於 &lt;code&gt;Result&lt;/code&gt; 是一個 enum，只有兩條路，不是正確就是錯誤，所以在 &lt;code&gt;main&lt;/code&gt; 這裡設置 &lt;code&gt;Result&lt;/code&gt; 也就代表了要回傳東西，我們在最後面擺上一個 &lt;code&gt;Ok(())&lt;/code&gt; 就好。&lt;/p&gt;

&lt;h3 id=&quot;unwrap&quot;&gt;取代 unwrap()&lt;/h3&gt;

&lt;p&gt;接下來其他的錯誤就可以把所有的 &lt;code&gt;unwrap()&lt;/code&gt; 都拿掉，但是選取 HTML 的部分如果壞掉，好像也不需要繼續往下執行，所以替換成 &lt;code&gt;?&lt;/code&gt; 表示暫不處理。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;let response = reqwest::get(url).await?;
let body = response.text().await?;
let document = Html::parse_document(&amp;amp;body);

let book_selector = Selector::parse(&quot;article.product_pod&quot;)?;
let title_selector = Selector::parse(&quot;h3 a&quot;)?;
let price_selector = Selector::parse(&quot;div.product_price .price_color&quot;)?;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;part-23705ea99a683cb&quot;&gt;可以加上失敗後顯示的文字&lt;/h3&gt;

&lt;p&gt;而在迴圈的部分如果找不到相對應的元素就再提示並顯示錯誤訊息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;for book in document.select(&amp;amp;book_selector) {
    let title_element = book.select(&amp;amp;title_selector).next().ok_or(&quot;找不到 Title 元素&quot;)?;
    let title = title_element
        .value()
        .attr(&quot;title&quot;)
        .ok_or(&quot;找不到 Title 屬性&quot;)?;
    let price = book
        .select(&amp;amp;price_selector)
        .next()
        .ok_or(&quot;找不到 Price 元素&quot;)?
        .text()
        .collect::&amp;lt;String&amp;gt;();

        // ...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;part-57e3069a57e74102&quot;&gt;拿取其他頁面的資料&lt;/h2&gt;

&lt;p&gt;由於最下面有分頁，代表其他頁面也有資料還沒撈取，而目前只有爬第一頁的資料，所以我們接下來試著爬完全部頁面的資料。&lt;/p&gt;

&lt;p&gt;我們可以先觀察第一頁跟其他頁的差異在哪。&lt;/p&gt;

&lt;p&gt;其實整個 HTML 架構都差不多，最大的差別只在於 URL 而已，例如第一頁是 &lt;code&gt;https://books.toscrape.com/&lt;/code&gt;，而第二頁則是 &lt;code&gt;https://books.toscrape.com/catalogue/page-2.html&lt;/code&gt;，剩下幾頁的差別都只是在 page 之後的數字差別而已，接下來比較方便的作法則是建立一個 client。&lt;/p&gt;

&lt;h2 id=&quot;client&quot;&gt;建立 client 並測試是否可以爬到第二頁&lt;/h2&gt;

&lt;p&gt;這一步驟要先使用 &lt;code&gt;reqwest&lt;/code&gt; 建立一個 client，比較方便去 get 不同頁面的 URL。下面的程式碼會用迴圈先試跑個兩圈，看看兩頁是不是都能成功連到，然後印出爬到的頁面跟狀態碼是否正確還有符合我們想要的。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;async fn main() -&amp;gt; Result&amp;lt;(), Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
    let client = reqwest::Client::builder().build()?;

    for page in 1..=2 {
        let url = if page == 1 {
            &quot;https://books.toscrape.com&quot;.to_string()
        } else {
            format!(&quot;https://books.toscrape.com/catalogue/page-{}.html&quot;, page)
        };

        println!(&quot;正在爬取頁面: {}&quot;, url);

        let response = client.get(&amp;amp;url).send().await?;
        println!(&quot;狀態: {}&quot;, response.status());

        if !response.status().is_success() {
            println!(&quot;狀態碼: {}&quot;, response.status());
            continue;
        }
    }

    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這裡可以試試看把網頁改成錯誤的會發生什麼事，例如把 URL 故意打錯。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/EbXBMgj.png&quot; alt=&quot;20240913005349&quot;&gt;&lt;/p&gt;

&lt;p&gt;到這一步應該都能成功讓兩個頁面的狀態都是 200，所以就可以繼續往下進行。&lt;/p&gt;

&lt;h2 id=&quot;part-c5d1c9c23b78b396&quot;&gt;計算每頁抓到的書是否正確&lt;/h2&gt;

&lt;p&gt;如果檢查每一頁應該可以發現每一頁的書都是固定的 20 本，所以檢查一下用選取器在第二頁是否也正常。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;for page in 1..=2 {
    // 省略
    let body = response.text().await?;
    let document = Html::parse_document(&amp;amp;body);
    let book_selector = Selector::parse(&quot;article.product_pod&quot;)?;
    // 省略

    let mut book_count = 0;

    for _book in document.select(&amp;amp;book_selector) {
        // 省略
        book_count += 1;
    }

    println!(&quot;在第 {} 頁找到 {} 本書&quot;, page, book_count);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;book_count&lt;/code&gt; 是一個會一直往上加的值，代表這個值需要一直改變，並且最後會使用這個改變後的變數，所以要使用 &lt;code&gt;mut&lt;/code&gt; 這個關鍵字來表示這個變數是可變。&lt;/p&gt;

&lt;p&gt;然後 for 迴圈的 &lt;code&gt;book&lt;/code&gt; 沒有加上 &lt;code&gt;_&lt;/code&gt; 的話，或者應該說在 Rust 的程式碼如果有定義但沒使用，在終端機應該可以看到一些警告，這不是錯誤，只是 Rust 會很 nice 地（雞婆）提醒您有變數沒使用，所以可以註解掉該變數，或者在變數前面加上 &lt;code&gt;_&lt;/code&gt;，表示目前暫時用不到。&lt;/p&gt;

&lt;p&gt;當然如果你不介意這些警告，也可以不用理他。&lt;/p&gt;

&lt;p&gt;執行 &lt;code&gt;cargo run&lt;/code&gt; 之後應該會看到兩頁都能撈到 20 本書，所以就可以試著跑完全部的頁面，只要把迴圈的數字改成最大頁數就好，以這個網站來看，改成 50 之後跑看看，觀察一下每一頁狀態是不是正常，找到的書本是不是正確的數字。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/HS1TzKe.png&quot; alt=&quot;20240913005408&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-d2e175ceed2fd712&quot;&gt;如果超過頁面會怎麼樣？&lt;/h2&gt;

&lt;p&gt;我們知道現在總共有 50 頁，但如果想要看看跑超過 50 頁會怎麼樣，我們來試試看，改成 51。&lt;/p&gt;

&lt;p&gt;其實就跟前面故意把 URL 改成錯誤一樣，在第一個迴圈就會出現錯誤，然後按照我們設想的錯誤並回傳錯誤訊息，所以使用正確的錯誤處理是非常好的一件事，這裡如果是用 &lt;code&gt;unwrap()&lt;/code&gt; 雖然也可能會回傳錯誤訊息，但這種錯誤是我們可以掌握並處理的。&lt;/p&gt;

&lt;h2 id=&quot;json&quot;&gt;儲存完整資料 -&amp;gt; JSON&lt;/h2&gt;

&lt;p&gt;其實現在跑下來是可以在終端機顯示全部並且完整的書名以及價錢，但 50 頁的資料量滿多的，而且也不好閱讀，所以讓我們試著把資料存成 JSON。&lt;/p&gt;

&lt;h3 id=&quot;crates-json&quot;&gt;安裝 crates 來處理 JSON&lt;/h3&gt;

&lt;p&gt;我們需要兩種 crates 來處理 JSON，這裡推薦：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/serde&quot;&gt;serde&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&quot;https://crates.io/crates/serde_json&quot;&gt;serde_json&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;安裝 serde 需要開啟完整的功能，所以在安裝可以這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash!&quot;&gt;cargo add serde -F derive
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;serde 會按照我們設定的 struct 去解析資料，然後再經由 serde_json 轉出 JSON。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/F33sAl4.png&quot; alt=&quot;20240913005422&quot;&gt;&lt;/p&gt;

&lt;p&gt;struct 是 Rust 中定義型別的一種方式，可以想像成類似 TS 的 interface。&lt;/p&gt;

&lt;h3 id=&quot;serde-file-struct&quot;&gt;使用 serde 以及 File 並定義 struct&lt;/h3&gt;

&lt;p&gt;這一步需要使用剛剛安裝的 serde 然後還需要使用 Rust 內建的 File 來轉出檔案，然後還需要定義 JSON 的格式，也就是 struct，然後使用 serde 來標記，最後才能給 serde_json 使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;use serde::{Deserialize, Serialize};
use std::fs::File;

#[derive(Serialize, Deserialize)]
struct Book {
    title: String,
    price: String,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;vec&quot;&gt;建立一個 Vec&lt;/h3&gt;

&lt;p&gt;建立完 JSON 的格式之後，由於 JSON 是由一個陣列包著物件這樣的格式，所以我們還需要建立一個陣列來使用。&lt;/p&gt;

&lt;p&gt;不過在 Rust 的世界中，陣列（array）只能是一個固定長度，並且有長度限制，所以除非你確切知道你的資料長度，所以一般動態資料會使用向量 (vector)。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;let client = reqwest::Client::builder().build()?;
let mut books = Vec::new();
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;json&quot;&gt;把每本書塞進 JSON&lt;/h3&gt;

&lt;p&gt;接下來就可以在 &lt;code&gt;book_selector&lt;/code&gt; 迴圈中把每本書都塞進 &lt;code&gt;books&lt;/code&gt; 這個 vector 當中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt; for book in document.select(&amp;amp;book_selector) {
    book_count += 1;
    let title_element = book.select(&amp;amp;title_selector).next().unwrap();
    let title = title_element
        .value()
        .attr(&quot;title&quot;)
        .ok_or(&quot;找不到 Title 屬性&quot;)?;
    let price = book
        .select(&amp;amp;price_selector)
        .next()
        .ok_or(&quot;找不到 Price 元素&quot;)?
        .text()
        .collect::&amp;lt;String&amp;gt;();

    books.push(Book {
        title: title.to_string(),
        price,
    });

    println!(&quot;書名: {}&quot;, title);
    // println!(&quot;價格: {}&quot;, price);
    println!(&quot;---&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後使用 serde_json 和 File 將資料寫成一個 json 檔案。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;let file = File::create(&quot;books.json&quot;)?;
serde_json::to_writer_pretty(file, &amp;amp;books)?;

println!(&quot;資料已存到 books.json&quot;);

Ok(())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後你可能會覺得有點奇怪，為什麼將 &lt;code&gt;title&lt;/code&gt; 跟 &lt;code&gt;price&lt;/code&gt; 塞入的時候，&lt;code&gt;price&lt;/code&gt; 並沒有像 &lt;code&gt;title&lt;/code&gt; 那樣轉成 string。&lt;/p&gt;

&lt;p&gt;這是因為 &lt;code&gt;Book&lt;/code&gt; 在 struct 中定義成 String，然後 &lt;code&gt;price&lt;/code&gt; 最後有轉成 String，而 &lt;code&gt;title&lt;/code&gt; 沒有，它的型別原本是 &amp;amp;str（字串切片）。所以你要在 push 的時候轉成 String 或者是這樣也可以：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;for book in document.select(&amp;amp;book_selector) {
    book_count += 1;
    let title_element = book.select(&amp;amp;title_selector).next().unwrap();
    let title = title_element
        .value()
        .attr(&quot;title&quot;)
        .ok_or(&quot;找不到 Title 屬性&quot;)?
        .to_string();
    let price = book
        .select(&amp;amp;price_selector)
        .next()
        .ok_or(&quot;找不到 Price 元素&quot;)?
        .text()
        .collect::&amp;lt;String&amp;gt;();

    books.push(Book {
        title,
        price,
    });
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後你就可以執行 &lt;code&gt;cargo run&lt;/code&gt; 並且將資料存成 JSON 了。&lt;/p&gt;

&lt;h2 id=&quot;excel&quot;&gt;如果想存成 Excel 可以嗎？&lt;/h2&gt;

&lt;p&gt;沒問題！Rust 的 crates 也可以找得到專門處理 excel 的套件，那就是 &lt;a href=&quot;https://crates.io/crates/xlsxwriter&quot;&gt;xlsxwriter&lt;/a&gt;。&lt;/p&gt;

&lt;h3 id=&quot;xlsxwriter&quot;&gt;安裝 xlsxwriter 並使用&lt;/h3&gt;

&lt;p&gt;按照說明安裝完之後並使用：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;use xlsxwriter::Workbook;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;let workbook = Workbook::new(&quot;books.xlsx&quot;)?;
let mut sheet = workbook.add_worksheet(None)?;

sheet.write_string(0, 0, &quot;書名&quot;, None)?;
sheet.write_string(0, 1, &quot;價格&quot;, None)?;

let mut row = 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;變數 &lt;code&gt;row&lt;/code&gt; 會按照資料筆數一直增加欄位，所以需要讓他是一個可變變數。
然後在迴圈中寫入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;for book in document.select(&amp;amp;book_selector) {
    book_count += 1;
    let title_element = book.select(&amp;amp;title_selector).next().unwrap();
    let title = title_element
        .value()
        .attr(&quot;title&quot;)
        .ok_or(&quot;找不到 Title 屬性&quot;)?;
    let price = book
        .select(&amp;amp;price_selector)
        .next()
        .ok_or(&quot;找不到 Price 元素&quot;)?
        .text()
        .collect::&amp;lt;String&amp;gt;();

    sheet.write_string(row, 0, title, None)?;
    sheet.write_string(row, 1, &amp;amp;price, None)?;

    books.push(Book {
        title: title.to_string(),
        price,
    });

    row += 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;你可能發現到 sheet 在寫入價格欄位時，&lt;code&gt;price&lt;/code&gt; 寫成了 &lt;code&gt;&amp;amp;price&lt;/code&gt;。
&lt;code&gt;&amp;amp;&lt;/code&gt; 是 Rust 中所有權常用的一個借用概念。&lt;/p&gt;

&lt;p&gt;如果拿掉的話，這裡 Cargo 會提示你使用 &lt;code&gt;&amp;amp;&lt;/code&gt;，不然會出錯。&lt;/p&gt;

&lt;p&gt;執行 &lt;code&gt;cargo run&lt;/code&gt; 應該就可以將資料存成 excel。&lt;/p&gt;

&lt;h2 id=&quot;part-65cea7fea4c33576&quot;&gt;自動取得全部頁面資料&lt;/h2&gt;

&lt;p&gt;目前已經可以爬完全部頁面的資料，不過如果未來網站資料變多的話，那麼是不是代表會超過 50 頁？
雖然是可以再手動修改頁數，但我們可以去偵測全部的總頁數，然後就可以自動爬完全部頁數的資料了。&lt;/p&gt;

&lt;p&gt;我們可以透過一個自定義的 function 來做這件事。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;async fn get_total_pages(client: &amp;amp;reqwest::Client) -&amp;gt; Result&amp;lt;u32, Box&amp;lt;dyn Error&amp;gt;&amp;gt; {
    let url = &quot;https://books.toscrape.com/index.html&quot;;
    let response = client.get(url).send().await?;
    let body = response.text().await?;
    let document = Html::parse_document(&amp;amp;body);

    let pager_selector = Selector::parse(&quot;ul.pager li.current&quot;)?;
    let pager_text = document
        .select(&amp;amp;pager_selector)
        .next()
        .ok_or(&quot;無法找到分頁資料&quot;)?
        .text()
        .collect::&amp;lt;String&amp;gt;();

    let total_pages = pager_text
        .split_whitespace()
        .last()
        .ok_or(&quot;無法取得總頁數&quot;)?
        .parse::&amp;lt;u32&amp;gt;()?;

    Ok(total_pages)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這裡會借用 &lt;code&gt;client&lt;/code&gt; 來使用選取器，然後並透過分頁的部分去計算總頁數。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Izj4Nyn.png&quot; alt=&quot;20240913005439&quot;&gt;&lt;/p&gt;

&lt;p&gt;這裡就可以取代掉原本的數字。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust!&quot;&gt;    // 取得總頁數
let total_pages = get_total_pages(&amp;amp;client).await?;
println!(&quot;總頁數: {}&quot;, total_pages);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;執行後，一樣可以正常寫入，但這樣的函式可以幫助我們動態去計算總頁數，然後取得全部的資料。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Fri, 13 Sep 2024 00:43:33 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-2024-hello-world.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 7 minutes</category>
    </item>
    <item>
      <title>Type or Interface?</title>
      <link>https://railquill.vercel.app/type-or-interface.html</link>
      <description>TypeScript 的 type 和 interface 有什麼不同？</description>
      <content:encoded><![CDATA[
        &lt;p&gt;在開發 TS 一段時間後，發覺 type 跟 interface 這兩個東西看起來很像，一直不太清楚使用的時機是什麼，所以研究了一下，寫了一篇文章記錄一下。&lt;/p&gt;

&lt;p&gt;站在巨人的肩膀上，我參考了這部影片，有些觀點很有趣：&lt;/p&gt;



&lt;p&gt;在開始之前，先簡單介紹一下這兩種東西，並比較一下兩者的差異。&lt;/p&gt;

&lt;h2 id=&quot;type&quot;&gt;什麼是 type？&lt;/h2&gt;

&lt;p&gt;type 是 TypeScript 中用來定義型別別名的關鍵字，它可以定義任何型別。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;type UserType = {
    name: string
    age: number
}

const user: UserType = {
    name: &quot;Bucky&quot;,
    age: 18,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;interface&quot;&gt;什麼是 interface&lt;/h2&gt;

&lt;p&gt;interface 是用來定義物件型別的一種方式，它主要用於描述物件的形狀。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;interface UserInter {
    name: string
    age: number
}

const user: UserInter = {
    name: &quot;Bucky&quot;,
    age: 18,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;typescript&quot;&gt;TypeScript 官方文件推薦哪一個？&lt;/h2&gt;

&lt;p&gt;在官方文件中，&lt;a href=&quot;https://www.typescriptlang.org/docs/handbook/2/everyday-types.html#differences-between-type-aliases-and-interfaces&quot;&gt;Differences Between Type Aliases and Interfaces&lt;/a&gt;這一段落最後有下一個結論：&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For the most part, you can choose based on personal preference, and TypeScript will tell you if it needs something to be the other kind of declaration. If you would like a heuristic, use interface until you need to use features from type.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;h2 id=&quot;interface&quot;&gt;interface 的局限性&lt;/h2&gt;

&lt;p&gt;在 Kyle 的影片當中，他提到了 interface 只能用在物件上，而不像 type 比較靈活，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;type StringType = string

const user: StringType = &quot;Bucky&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 interface 沒辦法這樣做，這樣做就會壞掉：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;interface StringInter = string

const user: StringInter = &quot;Bucky&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;會跟你說：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;string&#39; only refers to a type, but is being used as a value here.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;那麼 type 還可以做到什麼呢？&lt;/p&gt;

&lt;h2 id=&quot;type&quot;&gt;type 的靈活&lt;/h2&gt;

&lt;p&gt;例如一個變數可能有多個型別，type 可以定義聯合型別：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;type IdType = string | number

const orderId: IdType = &quot;123&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;type 還可以用於定義交叉型別：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;type A = { a: string }
type B = { b: number }
type AB = A &amp;amp; B

const ab: AB = { a: &quot;hello&quot;, b: 42 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;interface&quot;&gt;interface 的擴充性&lt;/h2&gt;

&lt;p&gt;interface 可以通過 &lt;code&gt;extends&lt;/code&gt; 關鍵字進行擴充：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;interface A {
  age: number
}

interface User extends A {
  name: string
}

const user: User = {
  name: &quot;John&quot;,
  age: 30,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但是 type 也可以通過交叉型別實現類似的擴充：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;type User = {
  name: string
} &amp;amp; {
  age: number
}

const user: User = {
  name: &quot;John&quot;,
  age: 30,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;type&quot;&gt;type 的獨特之處&lt;/h2&gt;

&lt;p&gt;type 可以用於定義聯合型別的物件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript!&quot;&gt;type User = {
  name: string
} | {
  age: number
}

const user1: User = { name: &quot;John&quot; }
const user2: User = { age: 30 }
const user3: User = { name: &quot;John&quot;, age: 30 } // 這也是合法的
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這是 interface 無法直接實現的功能。&lt;/p&gt;

&lt;h2 id=&quot;interface&quot;&gt;interface 的獨特特性：宣告合併&lt;/h2&gt;

&lt;p&gt;前面講了這麼多 type 做得到，但 interface 做不到的地方。不過 interface 確實是有一個 type 無法實現的特性是宣告合併（Declaration Merging）。&lt;/p&gt;

&lt;p&gt;可以讓你在多個地方定義同一個 interface，TypeScript 會自動將這些定義合併。例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;typescript&quot;&gt;interface Order {
  id: number
}

interface Order {
  name: string
}

interface Order {
  age: number
}

const order: Order = {
  id: 1,
  name: &quot;John&quot;,
  age: 30,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;但我想不到這樣做的好處有什麼，反而會降低可讀性。&lt;/p&gt;

&lt;h2 id=&quot;part-6543023dced&quot;&gt;總結&lt;/h2&gt;

&lt;p&gt;如果你需要定義複雜的型別（如聯合型別、交叉型別、條件類型等），使用 type。&lt;/p&gt;

&lt;p&gt;如果你主要想定義物件的結構，並且可能需要在未來擴展這個結構，那就可考慮使用 interface。&lt;/p&gt;

&lt;p&gt;最後，無論選擇 type 還是 interface 都是可以的，選擇哪一個主要取決於個人偏好和團隊約定。最重要的還是在整個專案中保持一致性，程式碼的可讀性和可維護性還是最重要的。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sun, 28 Jul 2024 15:55:31 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/type-or-interface.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 3 minutes</category>
    </item>
    <item>
      <title>Next.js 如何在 App Router 中使用 Context？</title>
      <link>https://railquill.vercel.app/next-js-app-router-context.html</link>
      <description>介紹如何在 Next.js 中使用 Context。</description>
      <content:encoded><![CDATA[
        &lt;p&gt;自從 Next.js 推出 App Router 後，讓開發者可以輕鬆使用強大的路由功能，但是同時也帶來一些在使用 React Hooks 的限制。本篇文章將探討如何在 App Router 中有效使用 &lt;code&gt;useContext&lt;/code&gt; 等 hooks 來傳遞 props，並解釋為什麼在某些情況下不能在 Server Component 中使用 hooks。&lt;/p&gt;

&lt;h2 id=&quot;app-router&quot;&gt;什麼是 App Router？&lt;/h2&gt;

&lt;p&gt;App Router 是 Next.js 13.4 版本引入的一項重大更新，它徹底改變了我們使用 React 的方式。這個新的路由系統是基於 React Server Components，為開發者提供了更強大、更靈活的工具來建立高效能的網頁應用。&lt;/p&gt;

&lt;h3 id=&quot;app-router&quot;&gt;App Router 的核心特性：&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;React Server Components：這是 App Router 的基礎。Server Components 在 Server 端運作，而不是在 Client 端。這代表著它們可以直接使用伺服器資源（如 DataBase），而不用將這些資源暴露給 Client 端或通過網絡傳輸不必要的數據。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;巢狀路由和 Layout：你可以輕鬆人性化地建立複雜的路由結構，如 &lt;code&gt;/news/[id]/page&lt;/code&gt;，並為多個頁面定義共享的 layout，不用再設定複雜的路由設定。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;簡化的資料取得：通過使用 React Server Components 中或從 API 取得資料，不用寫複雜的邏輯或管理狀態。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;Streaming 渲染：App Router 可以將資料從 Server Components 以 JSON chunk response 的形式傳輸到 Client 端，而不是一次性傳輸全部數據。這可以明顯升級效能和用戶體驗，特別是在網路較慢的情況下。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;內建 SEO 支持：App Router 自動產生 meta 標籤、sitemaps 和 robots.txt 文件，可以讓搜索引擎更好地找到你的網站。&lt;/p&gt;&lt;/li&gt;
&lt;li&gt;&lt;p&gt;更靈活的靜態和動態渲染：開發者可以選擇最適合的渲染策略，實現更精準的效能優化。&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&quot;app-router&quot;&gt;為什麼使用 App Router？&lt;/h3&gt;

&lt;p&gt;總的來說，App Router 不僅是 Next.js 的一個新功能，它為開發者提供了建立更快、更容易維護的 Web App 的工具。
然而，正如本文接下來將討論的，這種新的開發模式也帶來了一些挑戰，特別是在使用 React Hooks 時。理解如何在 App Router 環境中正確使用 Context 等功能，對於充分利用這個強大的新工具非常重要。&lt;/p&gt;

&lt;h2 id=&quot;server-component-hooks&quot;&gt;為什麼不能在 Server Component 中使用 Hooks？&lt;/h2&gt;

&lt;p&gt;在討論具體的使用情境之前,我們需要了解為什麼不能在 Server Components 中使用 hooks。&lt;/p&gt;

&lt;p&gt;Server Components 是在 Server 端渲染的，而 React hooks 的生命週期和狀態管理，這些在 Server 端是不存在的。因此，在 Server Components 中使用 hooks 會導致錯誤。&lt;/p&gt;

&lt;p&gt;解決這個問題的方法是將需要使用 hooks 的部分拆分為 Client Components。只要在該 component 最上方加上 &lt;code&gt;&#39;use client&#39;&lt;/code&gt;，這個作法就會把一個 component 標記為 Client Component，Next.js 就會知道這個 component 是在 Client 端運行的，而不是在 Server 端，所以在這裡可以安全地使用 hooks。&lt;/p&gt;

&lt;h2 id=&quot;props-child-component&quot;&gt;情境： 在頁面中將 Props 傳遞到 Child Component&lt;/h2&gt;

&lt;p&gt;讓我們來看一個非常常見的情況，展示如何在一個 Next.js 頁面中使用 Context 將 props 傳遞到 child component，甚至是更深層的 child component。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Vrv5oXr.png&quot; alt=&quot;20240714183523&quot;&gt;&lt;/p&gt;

&lt;p&gt;第一步，我們先建立一個 Context：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;&#39;use client&#39;
import { createContext, useContext, useState, ReactNode } from &#39;react&#39;

type ThemeContextType = {
  theme: string
  setTheme: (theme: string) =&amp;gt; void
}

const ThemeContext = createContext&amp;lt;ThemeContextType | undefined&amp;gt;(undefined)

export const ThemeProvider: React.FC&amp;lt;{ children: ReactNode }&amp;gt; = ({
  children
}) =&amp;gt; {
  const [theme, setTheme] = useState(&#39;light&#39;)

  return (
    &amp;lt;ThemeContext.Provider value={{ theme, setTheme }}&amp;gt;
      {children}
    &amp;lt;/ThemeContext.Provider&amp;gt;
  )
}

export const useTheme = () =&amp;gt; {
  const context = useContext(ThemeContext)
  if (context === undefined) {
    throw new Error(&#39;useTheme must be used within a ThemeProvider&#39;)
  }
  return context
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;稍微介紹一下這個 Context。一開始最重要的就是 &lt;code&gt;use client&lt;/code&gt;，這樣就可以在 Client Components 中使用 hooks。接著我們建立了一個 &lt;code&gt;ThemeContext&lt;/code&gt;，並且建立了一個 &lt;code&gt;ThemeProvider&lt;/code&gt; 來提供 theme 的值，最後我們建立了一個 &lt;code&gt;useTheme&lt;/code&gt; hook 來使用這個 Context。&lt;/p&gt;

&lt;p&gt;接下來，在 Page 中使用這個 Context：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;import { ThemeProvider } from &#39;@/context/themeContext&#39;

export default function Home() {
  return (
    &amp;lt;ThemeProvider&amp;gt;
      &amp;lt;main&amp;gt;&amp;lt;/main&amp;gt;
    &amp;lt;/ThemeProvider&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到這一步，不管是在畫面中的哪個地方，只要是在 &lt;code&gt;ThemeProvider&lt;/code&gt; 的子元素中，都可以使用 &lt;code&gt;useTheme&lt;/code&gt; 來取得 theme 的值。&lt;/p&gt;

&lt;p&gt;然後可以測試一下如果把 Context 的 &lt;code&gt;&#39;use client&#39;&lt;/code&gt; 拿掉，會發生什麼事情。&lt;/p&gt;

&lt;p&gt;畫面上就會出現這個錯誤：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/r08TNFR.png&quot; alt=&quot;20240714170606&quot;&gt;&lt;/p&gt;

&lt;p&gt;錯誤訊息會跟你說，你要使用 React 的 hook，就必須要在 Client Component 中使用，因為你不宣告 &lt;code&gt;&#39;use client&#39;&lt;/code&gt;，所以這個 component 預設就會被認為是 Server Component。&lt;/p&gt;

&lt;p&gt;接下來我們建立兩個 child component，分別是 &lt;code&gt;ParentComponent&lt;/code&gt; 跟 &lt;code&gt;ChildComponent&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;&#39;use client&#39;
import { useTheme } from &#39;@/context/themeContext&#39;
import ChildComponent from &#39;./Child&#39;

export default function ParentComponent() {
  const { theme } = useTheme()

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;p&amp;gt;Current theme: {theme}&amp;lt;/p&amp;gt;
      &amp;lt;ChildComponent /&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;&#39;use client&#39;
import { useTheme } from &#39;@/context/themeContext&#39;

export default function ChildComponent() {
  const { theme, setTheme } = useTheme()

  return (
    &amp;lt;button
      type=&#39;button&#39;
      onClick={() =&amp;gt; setTheme(theme === &#39;light&#39; ? &#39;dark&#39; : &#39;light&#39;)}
    &amp;gt;
      Toggle Theme
    &amp;lt;/button&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後在 Home Page 中 import &lt;code&gt;ParentComponent&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;import ParentComponent from &#39;@/components/Parent&#39;

export default function Home() {
  return (
    &amp;lt;ThemeProvider&amp;gt;
      &amp;lt;main&amp;gt;
        &amp;lt;ParentComponent /&amp;gt;
      &amp;lt;/main&amp;gt;
    &amp;lt;/ThemeProvider&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;透過以上的方法，我們就可以做到不管在哪個 component 中，只要是在 &lt;code&gt;ThemeProvider&lt;/code&gt; 的子元素中，都可以使用 &lt;code&gt;useTheme&lt;/code&gt; 來取得 theme 的值，並且可以透過 &lt;code&gt;setTheme&lt;/code&gt; 來改變 theme 的值，這樣就可以在 Next.js 中使用 Context 來傳遞 props。&lt;/p&gt;

&lt;p&gt;下面提供給大家一個 CodeSandbox 試玩：&lt;/p&gt;



      ]]></content:encoded>
      <pubDate>Sun, 14 Jul 2024 15:57:00 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/next-js-app-router-context.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 3 minutes</category>
    </item>
    <item>
      <title>React 19 Beta 新武器解鎖體驗</title>
      <link>https://railquill.vercel.app/react-19-beta.html</link>
      <description>介紹 React 19 Beta 新 Hooks。</description>
      <content:encoded><![CDATA[
        &lt;p&gt;經過長時間的等待，自從 React 18 在 2022 年推出以來，React 19 Beta 版終於在近期與開發者見面了。作為 React 18 的下一個主要版本，React 19 帶來了許多讓開發者心動的新特性，這次我們就先來一探究竟有什麼新的功能。&lt;/p&gt;

&lt;h2 id=&quot;usetransition&quot;&gt;useTransition&lt;/h2&gt;

&lt;p&gt;在前端操作中，經常會碰到需要更新狀態的情況，例如：使用者點擊按鈕後，需要更新 UI 來響應這個操作。然而，有些狀態更新可能計算量較大或者涉及非同步操作，執行時間較長。&lt;/p&gt;

&lt;p&gt;以下是一個範例，當使用者輸入名字後，點擊按鈕，會呼叫 API 更新名字，並且在更新過程中，按鈕會變成不可點擊的狀態。&lt;code&gt;updateNameAPI&lt;/code&gt; 這個函式會模擬 API 的行為。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { useState } from &#39;react&#39;

const updateNameAPI = async (newName) =&amp;gt; {
  return new Promise((resolve, reject) =&amp;gt; {
    setTimeout(() =&amp;gt; {
      const shouldError = newName.includes(&#39;error&#39;)
      if (shouldError) {
        reject(`名字不能包含&quot;error&quot;`)
      } else {
        resolve(`你的新名字是: ${newName}`)
      }
    }, 1000)
  })
}

const Pending = () =&amp;gt; {
  const [name, setName] = useState(&#39;&#39;)
  const [error, setError] = useState(null)
  const [isPending, setIsPending] = useState(false)

  const handleSubmit = async () =&amp;gt; {
    setIsPending(true)
    const error = await updateNameAPI(name)
    setIsPending(false)
    if (error) {
      setError(error)
      return
    }
  }

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;input value={name} onChange={(e) =&amp;gt; setName(e.target.value)} /&amp;gt;
      &amp;lt;button onClick={handleSubmit} disabled={isPending}&amp;gt;
        {isPending ? &#39;更新中...&#39; : &#39;更新名字&#39;}
      &amp;lt;/button&amp;gt;
      {error &amp;amp;&amp;amp; &amp;lt;p style={{ color: &#39;red&#39; }}&amp;gt;{error}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;可以看到，這段程式碼中，我們使用了三個 &lt;code&gt;useState&lt;/code&gt; 來管理狀態，並且在 &lt;code&gt;handleSubmit&lt;/code&gt; 中，使用 &lt;code&gt;setIsPending&lt;/code&gt; 來控制按鈕是否可點擊，以及在 API 回傳錯誤時，使用 &lt;code&gt;setError&lt;/code&gt; 來顯示錯誤訊息。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;useTransition&lt;/code&gt; 這個 hook 已經不是新東西了，它在 React 18 中就已經出現，但在 React 19 中，它被進一步改進，讓我們更容易地處理非同步操作。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { useState, useTransition } from &#39;react&#39;

const Pending = () =&amp;gt; {
  const [name, setName] = useState(&#39;&#39;)
  const [error, setError] = useState(null)
  const [isPending, startTransition] = useTransition()

  const handleSubmit = () =&amp;gt; {
    startTransition(async () =&amp;gt; { // 使用 startTransition 包裹非同步操作
      const error = await updateNameAPI(name)
      if (error) {
        setError(error)
        return
      }
    })
  }

  // startTransition 會自動處理 pending 狀態
  // 在非同步操作期間,isPending 為 true 
  // 操作完成後,isPending 變為 false

  return (
    &amp;lt;div&amp;gt;
      &amp;lt;input value={name} onChange={(e) =&amp;gt; setName(e.target.value)} /&amp;gt;
      &amp;lt;button onClick={handleSubmit} disabled={isPending}&amp;gt;
        {isPending ? &#39;更新中...&#39; : &#39;更新名字&#39;}
      &amp;lt;/button&amp;gt;
      {error &amp;amp;&amp;amp; &amp;lt;p style={{ color: &#39;red&#39; }}&amp;gt;{error}&amp;lt;/p&amp;gt;}
    &amp;lt;/div&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這裡我們簡單地使用 &lt;code&gt;useTransition&lt;/code&gt; 來取代 &lt;code&gt;setIsPending&lt;/code&gt;，在 &lt;code&gt;useTransition&lt;/code&gt; 每次非同步操作時，會自動幫我們處理好 pending 的狀態，讓我們不需要再手動管理。&lt;/p&gt;

&lt;h2 id=&quot;useactionstate&quot;&gt;useActionState&lt;/h2&gt;

&lt;p&gt;前面展示了 &lt;code&gt;useTransition&lt;/code&gt; 已經簡化了一些程式碼，接下來看到 &lt;code&gt;useActionState&lt;/code&gt; 這個新 hook，可以更進一步簡化我們的程式碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { useActionState } from &#39;react&#39;

const UseActionStateExample = () =&amp;gt; {
  const [error, submitAction, isPending] = useActionState(
    async (state, formData) =&amp;gt; {
      const newName = formData.get(&#39;name&#39;)
      const error = await updateNameAPI(newName)
      if (error) {
        return error
      }
    }
  )

  const handleSubmit = (e) =&amp;gt; {
    e.preventDefault()
    const formData = new FormData(e.target)
    submitAction(formData) // 調用 submitAction 提交表單
  }

  // useActionState 自動管理 error 和 isPending 狀態
  // 在非同步操作期間，isPending 為 true
  // 操作完成後，根據返回值更新 error 狀態

  return (
    &amp;lt;form onSubmit={handleSubmit}&amp;gt;
      &amp;lt;input name=&#39;name&#39; /&amp;gt;
      &amp;lt;button type=&#39;submit&#39; disabled={isPending}&amp;gt;
        {isPending ? &#39;更新中...&#39; : &#39;更新名字&#39;}
      &amp;lt;/button&amp;gt;
      {error &amp;amp;&amp;amp; &amp;lt;p style={{ color: &#39;red&#39; }}&amp;gt;{error}&amp;lt;/p&amp;gt;}
    &amp;lt;/form&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;useActionState&lt;/code&gt; 分別回傳了三個值，第一個是錯誤訊息，第二個是一個函式，用來提交表單，第三個是一個布林值，用來判斷是否正在執行中。&lt;/p&gt;

&lt;p&gt;這個例子中，我們完全不需要 &lt;code&gt;useState&lt;/code&gt;，只需要使用 &lt;code&gt;useActionState&lt;/code&gt; 就可以完成前面使用 &lt;code&gt;useTransition&lt;/code&gt; 所有的操作，這樣可以讓我們的程式碼更加簡潔。不過眼尖的你，可能也發現到這個例子中，使用的是 &lt;code&gt;form&lt;/code&gt; 表單的操作，所以這也表示 &lt;code&gt;useActionState&lt;/code&gt; 只能用在表單操作上。&lt;/p&gt;

&lt;h2 id=&quot;useformstatus&quot;&gt;useFormStatus&lt;/h2&gt;

&lt;p&gt;在以前的 React 中，如果按鈕元件獨立出來，要讓按鈕元件知道目前表單是否正在執行中，需要透過 &lt;code&gt;props&lt;/code&gt; 傳遞，這樣會讓程式碼變得複雜，不過在 React 19 中，我們可以使用 &lt;code&gt;useFormStatus&lt;/code&gt; 來取得表單的狀態：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { useActionState } from &#39;react&#39;
import { useFormStatus } from &#39;react-dom&#39;

const SubmitButton = () =&amp;gt; {
  const { pending } = useFormStatus()
  // 從 useFormStatus 獲取 pending 狀態
  return (
    &amp;lt;button type=&#39;submit&#39; disabled={pending}&amp;gt;
      {pending ? &#39;更新中...&#39; : &#39;更新名字&#39;}
    &amp;lt;/button&amp;gt;
  )
}

// useFormStatus 讀取父 &amp;lt;form&amp;gt; 的 pending 狀態
// 無需通過 props 傳遞，降低了組件耦合

const UseFormStatus = () =&amp;gt; {
  const [error, submitAction] = useActionState(async (state, formData) =&amp;gt; {
    const newName = formData.get(&#39;name&#39;)
    const error = await updateNameAPI(newName)
    if (error) {
      return error
    }
  })

  const handleSubmit = async (formData) =&amp;gt; {
    submitAction(formData)
  }

  return (
    &amp;lt;form action={handleSubmit}&amp;gt;
      &amp;lt;input name=&#39;name&#39; /&amp;gt;
      &amp;lt;SubmitButton /&amp;gt;
      {error &amp;amp;&amp;amp; &amp;lt;p style={{ color: &#39;red&#39; }}&amp;gt;{error}&amp;lt;/p&amp;gt;}
    &amp;lt;/form&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在上面的例子中，示範了使用 &lt;code&gt;useFormStatus&lt;/code&gt; 搭配 &lt;code&gt;useActionState&lt;/code&gt; 來簡化表單的操作，前者可以不需要傳遞 &lt;code&gt;props&lt;/code&gt; 就可以直接幫我們處理運作中的狀態，這樣後者也可以不需要取出 &lt;code&gt;isPending&lt;/code&gt; 來判斷是否正在執行中。&lt;/p&gt;

&lt;h2 id=&quot;useoptimistic&quot;&gt;useOptimistic&lt;/h2&gt;

&lt;p&gt;在某些情境下，當使用者提交表單時，我們可以先假設使用者的操作是成功的，然後再等待 API 回傳結果，這樣可以讓使用者感受到更快的回饋，這個概念就是所謂的 &lt;code&gt;Optimistic UI&lt;/code&gt;，在 React 19 中，我們可以使用 &lt;code&gt;useOptimistic&lt;/code&gt; 來實現這個功能：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { useState } from &#39;react&#39;
import { useOptimistic } from &#39;react&#39;

const OptimisticExample = () =&amp;gt; {
  const [title, setTitle] = useState(&#39;React 18&#39;)
  const [optimisticTitle, setOptimisticTitle] = useOptimistic(title)

  const submitForm = async () =&amp;gt; {
    const newTitle = &#39;React 19&#39;
    setOptimisticTitle(newTitle) // 立即渲染 optimistic 狀態
    const res = await new Promise((resolve) =&amp;gt; {
      setTimeout(() =&amp;gt; {
        resolve(`${newTitle} Beta`)
      }, 1000)
    })
    setTitle(res) // 更新為最終結果
  }

  // useOptimistic 使得我們可以優雅地實現 optimistic UI
  // 先展示期望的最終狀態，等待非同步操作完成後再更新為實際結果

  return (
    &amp;lt;form action={submitForm}&amp;gt;
      &amp;lt;h1&amp;gt;{optimisticTitle}&amp;lt;/h1&amp;gt;
      &amp;lt;button type=&#39;submit&#39;&amp;gt;更新&amp;lt;/button&amp;gt;
    &amp;lt;/form&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在這個例子中，我們使用 &lt;code&gt;useOptimistic&lt;/code&gt; 來取代 &lt;code&gt;useState&lt;/code&gt;，這樣就可以讓我們在提交表單時，先更新 UI，然後再等待 API 回傳結果，這樣可以讓使用者感受到更快的回饋。&lt;/p&gt;

&lt;h2 id=&quot;use&quot;&gt;use&lt;/h2&gt;

&lt;p&gt;在之前版本的 React 中，如果想讀取一些外部的 API 資料，一般都會使用 &lt;code&gt;useEffect&lt;/code&gt; 來處理，可以先看以下的範例：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { useState, useEffect } from &#39;react&#39;

const Messages = ({ messages }) =&amp;gt; {
  return (
    &amp;lt;ul&amp;gt;
      {messages.map((message) =&amp;gt; (
        &amp;lt;li key={message.id}&amp;gt;
          &amp;lt;h2&amp;gt;{message.title}&amp;lt;/h2&amp;gt;
          &amp;lt;p&amp;gt;{message.body}&amp;lt;/p&amp;gt;
        &amp;lt;/li&amp;gt;
      ))}
    &amp;lt;/ul&amp;gt;
  )
}

function FetchExample() {
  const [messages, setMessages] = useState([])
  const [loading, setLoading] = useState(true)

  useEffect(() =&amp;gt; {
    const fetchData = async () =&amp;gt; {
      try {
        const res = await fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;)
        const data = await res.json()
        setMessages(data)
        setLoading(false)
      } catch (err) {
        console.error(err)
      } finally {
        setLoading(false)
      }
    }

    fetchData()
  }, [])

  if (loading) {
    return &amp;lt;p&amp;gt;⌛Downloading message...&amp;lt;/p&amp;gt;
  }

  return &amp;lt;Messages messages={messages} /&amp;gt;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 React 19 中，我們可以使用 &lt;code&gt;use&lt;/code&gt; 來取代 &lt;code&gt;useEffect&lt;/code&gt;，這樣可以讓我們的程式碼更加簡潔：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { use, Suspense } from &#39;react&#39;

const fetchData = async () =&amp;gt; {
  const res = await fetch(&#39;https://jsonplaceholder.typicode.com/posts&#39;)
  return res.json()
}

const Messages = () =&amp;gt; {
  const messages = use(fetchData())
  // use 讀取非同步資源，並暫停渲染直到完成

  return (
    &amp;lt;ul&amp;gt;
      {messages.map((message) =&amp;gt; (
        &amp;lt;li key={message.id}&amp;gt;
          &amp;lt;h2&amp;gt;{message.title}&amp;lt;/h2&amp;gt;
          &amp;lt;p&amp;gt;{message.body}&amp;lt;/p&amp;gt;
        &amp;lt;/li&amp;gt;
      ))}
    &amp;lt;/ul&amp;gt;
  )
}

// use 簡化了非同步讀取資源的實現
// 不需要使用 useEffect 提高可讀性

function UseExample() {
  return (
    &amp;lt;Suspense fallback={&amp;lt;p&amp;gt;⌛Downloading message...&amp;lt;/p&amp;gt;}&amp;gt;
      &amp;lt;Messages /&amp;gt;
    &amp;lt;/Suspense&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;context&quot;&gt;Context&lt;/h2&gt;

&lt;p&gt;最後來介紹 React 19 的 Context，這個部分算是有點小變動，以往在使用 Context 的時候，需要加上一個 &lt;code&gt;Provider&lt;/code&gt;，像是 &lt;code&gt;&amp;lt;Context.Provider&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;但在 React 19 中，我們可以直接使用 &lt;code&gt;Context&lt;/code&gt; 來取代 &lt;code&gt;Provider&lt;/code&gt;，這樣可以讓我們的程式碼更加簡潔：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx!&quot;&gt;import { createContext, useContext } from &#39;react&#39;

// 新建 Context
const ThemeContext = createContext(&#39;light&#39;)

function ThemeProvider({ children }) {
  const theme = &#39;light&#39;

  // 使用新語法渲染 &amp;lt;Context&amp;gt; 作為 provider
  return &amp;lt;ThemeContext value={theme}&amp;gt;{children}&amp;lt;/ThemeContext&amp;gt;
}

function ThemedButton() {
  // 使用 Context
  const theme = useContext(ThemeContext)

  return (
    &amp;lt;button
      style={{
        backgroundColor: theme === &#39;light&#39; ? &#39;white&#39; : &#39;black&#39;,
        color: theme === &#39;light&#39; ? &#39;black&#39; : &#39;white&#39;
      }}
    &amp;gt;
      I am a {theme} themed button
    &amp;lt;/button&amp;gt;
  )
}

const ContextExample = () =&amp;gt; {
  return (
    &amp;lt;ThemeProvider&amp;gt;
      &amp;lt;ThemedButton /&amp;gt;
    &amp;lt;/ThemeProvider&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在這個例子中，當傳遞 &lt;code&gt;value&lt;/code&gt; 為 &lt;code&gt;light&lt;/code&gt; 時，&lt;code&gt;ThemedButton&lt;/code&gt; 會顯示一個白色的按鈕，當傳遞 &lt;code&gt;value&lt;/code&gt; 為 &lt;code&gt;dark&lt;/code&gt; 時，&lt;code&gt;ThemedButton&lt;/code&gt; 會顯示一個黑色的按鈕。&lt;/p&gt;

&lt;h2 id=&quot;part-6542fd4e95a&quot;&gt;結論&lt;/h2&gt;

&lt;p&gt;React 19 Beta 還有其他功能，這篇文章只是挑出一些常用的情境可使用的 hook 和 API 來介紹，想了解更多的話，在 React 19 正式版推出再來做更加詳細的介紹。&lt;/p&gt;

&lt;p&gt;總的來說，React 19 Beta 為開發者帶來了許多改變，讓非同步渲染、數據獲取和更新的體驗獲得極大提升。雖然這只是一個 Beta 版本，但這些新功能和改進都值得我們熱烈期待 React 19 的正式到來。最後讓我們拭目以待，並為即將到來的 React 開發新紀元做好準備吧！&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Wed, 08 May 2024 17:26:20 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/react-19-beta.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 5 minutes</category>
    </item>
    <item>
      <title>使用 Leptos 建立和部署 WASM 到 GCP</title>
      <link>https://railquill.vercel.app/leptos-wasm-gcp.html</link>
      <description>2023 DevFest Taipei 議程之一，介紹如何使用 Leptos 建立和部署 WASM 到 GCP。</description>
      <content:encoded><![CDATA[
        &lt;p&gt;這篇文章是由 Google Developer Group(GDG) 主辦的 DevFest Taipei 2023 其中的一個議程，主題是 - 使用 Leptos 建立和部署 WASM 到 GCP。&lt;/p&gt;

&lt;h2 id=&quot;leptos&quot;&gt;什麼是 Leptos&lt;/h2&gt;

&lt;p&gt;近年來，Rust 語言越來越受到關注，而有關 Web 端的生態系更是蓬勃發展，不管是前端還是後端，都有許多優秀的框架可以使用，而 Leptos 就是其中一個框架。&lt;/p&gt;

&lt;p&gt;那麼 Leptos 有什麼特別的呢？&lt;/p&gt;

&lt;p&gt;Leptos 標榜是一個全端框架，話雖如此，但還是以前端為主，真要說的話，其角色有點類似於 Next.js。而 Leptos 提供了兩種 render 的方式，分別是：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Client-side rendering(CSR)&lt;/li&gt;
&lt;li&gt;Server-side rendering(SSR)&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;而不管是哪一種 render 的方式，都是使用 WASM 來實現的。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/RKVo9NP.png&quot; alt=&quot;Leptos benchmark&quot;&gt;&lt;/p&gt;

&lt;p&gt;作為效能優異的 Rust 語言，Leptos 也不例外，其效能也是非常優秀的，如上圖 Leptos 官網所示，Leptos 的效能比起其他框架來說，是非常優秀的。&lt;/p&gt;

&lt;h2 id=&quot;wasm&quot;&gt;什麼是 WASM&lt;/h2&gt;

&lt;p&gt;WASM 是 WebAssembly 的縮寫，是一種可以在瀏覽器上執行的低階語言，可以將其他語言編譯成 WASM，然後在瀏覽器上執行。&lt;/p&gt;

&lt;p&gt;根據 MDN 的說法，WASM 是一種可移植、大小、效能都很好的格式，可以在瀏覽器上執行，而且可以跨平台，不管是在桌面、行動裝置、IoT 裝置，都可以執行。&lt;/p&gt;

&lt;p&gt;既然 WASM 這麼猛，是不是表示未來前端的趨勢就是 WASM 了呢？其實也不是，WASM 雖然可以在瀏覽器上執行，但是它並不是一種語言，而是一種格式，所以它只是一種載具，而不是一種語言，所以它並不會取代 JavaScript，而是會和 JavaScript 一起使用。&lt;/p&gt;

&lt;p&gt;簡單來說，WASM 需要 JavaScript 來執行，所以 JavaScript 和 WASM 是互補的關係，而不是取代的關係。&lt;/p&gt;

&lt;h2 id=&quot;wasm-javascript&quot;&gt;WASM 怎麼跟 JavaScript 搭配&lt;/h2&gt;

&lt;p&gt;WASM 可以透過 wasm-bindgen 來跟 JavaScript 搭配使用，wasm-bindgen 可以讓 JavaScript 和 WASM 互相交換數據，可以把 wasm-bindgen 想像成一個橋樑，讓 JavaScript 和 WASM 互相溝通。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OxBO8IW.png&quot; alt=&quot;wasm-bindgen 橋樑示意圖&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;leptos&quot;&gt;Leptos 初體驗&lt;/h2&gt;

&lt;p&gt;首先，先選擇使用哪種 render 的方式，這裡選擇使用 Server-side rendering。&lt;/p&gt;

&lt;p&gt;接著，按照以下步驟執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;cargo install cargo-leptos
cargo leptos new --git https://github.com/leptos-rs/start
cd [your project name]
cargo leptos watch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;稍微講一下 &lt;code&gt;cargo-leptos&lt;/code&gt;，這是一個 cargo 的 工具，可以讓我們使用 cargo 來建立 Leptos 專案，而 &lt;code&gt;cargo leptos new&lt;/code&gt; 則是用來建立新專案，&lt;code&gt;cargo leptos watch&lt;/code&gt; 則是用來啟動開發伺服器。&lt;/p&gt;

&lt;p&gt;這裡預設是使用 actix-web 來處理後端 server，也可以選擇 Axum，不過這裡就不多做介紹了。&lt;/p&gt;

&lt;h3 id=&quot;intoview&quot;&gt;IntoView&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/hSABXYf.png&quot; alt=&quot;Leptos-App&quot;&gt;&lt;/p&gt;

&lt;p&gt;在 Leptos 中，&lt;code&gt;IntoView&lt;/code&gt; 是一個重要的特徵（trait），用於將 Rust code 轉換成可以在瀏覽器中顯示的部分。&lt;/p&gt;

&lt;p&gt;當使用 &lt;code&gt;view!&lt;/code&gt; 來定義 UI 界面時，&lt;code&gt;IntoView&lt;/code&gt; 讓這些 Rust component 可以轉換成 HTML。這樣，開發者就可以用 Rust 編寫 Web 應用的前端，而不是使用傳統的 HTML、CSS 或 JavaScript。這種方法有助於在 Rust 生態系統中保持類型安全和效能優勢，同時提供不同的前端開發體驗。&lt;/p&gt;

&lt;h3 id=&quot;create_signal&quot;&gt;create_signal&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/nnKA04g.png&quot; alt=&quot;Leptos 的狀態&quot;&gt;&lt;/p&gt;

&lt;p&gt;在 Leptos 中，狀態是由 &lt;code&gt;Signal&lt;/code&gt; 來管理的，而 &lt;code&gt;Signal&lt;/code&gt; 可以透過 &lt;code&gt;create_signal&lt;/code&gt; 來建立，&lt;code&gt;create_signal&lt;/code&gt; 會回傳一個 &lt;code&gt;Signal&lt;/code&gt;，而 &lt;code&gt;Signal&lt;/code&gt; 可以透過 &lt;code&gt;get&lt;/code&gt; 來取得目前的狀態，也可以透過 &lt;code&gt;set&lt;/code&gt; 來設定狀態。&lt;/p&gt;

&lt;p&gt;在圖片的例子中，更新狀態使用了 &lt;code&gt;update&lt;/code&gt; 這個 function，這個 function 會接收一個 closure，而 closure 會接收一個 &lt;code&gt;&amp;amp;mut&lt;/code&gt; 的參數，這個參數就是目前的狀態，而在 closure 中，我們可以對狀態做任何的操作，最後再回傳一個新的狀態，這樣就可以更新狀態了。&lt;/p&gt;

&lt;p&gt;寫法上有點類似於 React 的 &lt;code&gt;useState&lt;/code&gt;，如果有寫過 React 的話，應該會比較好理解。&lt;/p&gt;

&lt;h3 id=&quot;actix-web&quot;&gt;Actix-web 處理後端狀態&lt;/h3&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/sgGEzAX.png&quot; alt=&quot;actix-web&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果選擇的是 SSR 的話，預設會使用 actix-web 來處理後端的狀態，而 actix-web 是一個非常優秀的 Rust web framework，效能非常好，而且也有很多的 middleware 可以使用。&lt;/p&gt;

&lt;h2 id=&quot;part-3c6ef4a28e30d3e0&quot;&gt;建立一個新專案&lt;/h2&gt;

&lt;p&gt;接下來，就可以把 Leptos 專案部署到 GCP 上了，首先，先建立一個新專案，這裡以 &lt;code&gt;was-demo&lt;/code&gt; 為例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/7DiszI3.png&quot; alt=&quot;gcp 專案&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;gcp-sdk&quot;&gt;安裝 GCP SDK&lt;/h2&gt;

&lt;p&gt;然後到&lt;a href=&quot;https://cloud.google.com/sdk/docs/install&quot;&gt;這裡&lt;/a&gt;下載 SDK，選擇適合的作業系統，這裡以 MacOS 為例，我下載的是 macOS 64-bit 版本（ARM64, Apple M1 silicon）。&lt;/p&gt;

&lt;p&gt;下載後會是一個壓縮檔，解壓縮後放入適合的位置，我是放在使用者的目錄下。並且執行以下指令來安裝：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;./google-cloud-sdk/install.sh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;完成之後，執行以下指令來初始化：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;./google-cloud-sdk/bin/gcloud init
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來就會進入初始化的流程，會要求你登入 Google 帳號，登入之後，會要求你選擇專案，選擇剛剛建立的專案。&lt;/p&gt;

&lt;h2 id=&quot;docker-image&quot;&gt;建立 Docker Image&lt;/h2&gt;

&lt;p&gt;要部署 Leptos 專案，最好的方式就是使用 Docker。建立一個 &lt;code&gt;Dockerfile&lt;/code&gt;，可以直接用官網提供的範例：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/BVQG8l7.png&quot; alt=&quot;dockerfile&quot;&gt;&lt;/p&gt;

&lt;p&gt;這個 &lt;code&gt;Dockerfile&lt;/code&gt; 會建立一個 Docker Image，這個 Image 會包含我們的程式碼，以及執行程式碼所需要的環境。&lt;/p&gt;

&lt;p&gt;接著，執行以下指令來建立 Docker Image：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;docker build -t leptos-example .
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後，執行以下指令來啟動 Docker Container：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;docker run -p 8080:8080 leptos-example
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;打開瀏覽器，輸入 &lt;code&gt;http://localhost:8080&lt;/code&gt;，看到有畫面出現就代表成功了。&lt;/p&gt;

&lt;h2 id=&quot;google-container-registry-api&quot;&gt;啟動 Google Container Registry API&lt;/h2&gt;

&lt;p&gt;到 &lt;a href=&quot;https://console.cloud.google.com/&quot;&gt;Google Cloud Console&lt;/a&gt; 啟用 Container Registry API。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/4GigPc1.png&quot; alt=&quot;20231202150742&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;docker-image-google-container-registry&quot;&gt;上傳 Docker Image 到 Google Container Registry&lt;/h2&gt;

&lt;p&gt;首先，確保在本機上已經登入 GCP：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gcloud auth login
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;也可以看一下自己的 config 是否正確：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gcloud auth configure-docker
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;並針對 Image 做標記：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;docker tag leptos-example gcr.io/was-demo-406407/leptos-example
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後，上傳 Image 到 GCR：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;docker push gcr.io/was-demo-406407/leptos-example
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;app-engine&quot;&gt;部署到 App Engine&lt;/h2&gt;

&lt;p&gt;首先，建立一個 &lt;code&gt;app.yaml&lt;/code&gt;，內容如下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;yaml&quot;&gt;runtime: custom
env: flex

automatic_scaling:
  min_num_instances: 1
  max_num_instances: 2

resources:
  cpu: 1
  memory_gb: 1
  disk_size_gb: 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個部分，由於我們是使用 Docker Image 來部署，所以要使用 &lt;code&gt;custom&lt;/code&gt; 這個 runtime，而 &lt;code&gt;env: flex&lt;/code&gt; 則是使用 flexible 環境。&lt;/p&gt;

&lt;p&gt;然後，執行以下指令來部署：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gcloud app deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;會問你要部署到那一個區域，選擇適合的區域，這裡選擇 &lt;code&gt;asia-east1&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;接著就會開始部署，不過這裡遇到一個問題，似乎超過 10 分鐘就會 timeout，所以我們要設定一下 timeout 的時間：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gcloud config set app/cloud_build_timeout 1200
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;比較好的作法可能還是要調整一下 Docker Image 的大小，不過這裡就先這樣了。&lt;/p&gt;

&lt;p&gt;再次執行以下指令來部署：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;gcloud app deploy
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;部署成功之後，可以看到類似以下的畫面：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/Arn1kYT.png&quot; alt=&quot;20231202204511&quot;&gt;&lt;/p&gt;

&lt;p&gt;其中，會跟你說可以執行兩個指令，一個是 &lt;code&gt;gcloud app browse&lt;/code&gt;，另一個是 &lt;code&gt;gcloud app logs tail -s default&lt;/code&gt;，前者是開啟瀏覽器，後者是開啟 log。&lt;/p&gt;

&lt;p&gt;以上就是如何將 Leptos 專案部署到 GCP 上的流程。&lt;/p&gt;

&lt;p&gt;整體來說，這次 Leptos 的開發體驗很不錯，部署到 App Engine 的流程也算簡單，之後應該會把一些專案改寫成 Leptos 看看。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sat, 16 Dec 2023 16:02:32 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/leptos-wasm-gcp.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 3 minutes</category>
    </item>
    <item>
      <title>Rust Web 之旅：新時代的後端開發</title>
      <link>https://railquill.vercel.app/rust-web.html</link>
      <description>2023 COSCUP Rust 議程軌之一，介紹 Rust 在後端開發的應用，以 Tide 為例。</description>
      <content:encoded><![CDATA[
        &lt;p&gt;這篇文章是 2023 COSCUP Rust 議程軌之一，介紹 Rust 在後端開發的應用，以 Tide 為例。&lt;/p&gt;

&lt;p&gt;Rust 已經連續多年成為 Stack Overflow 最受歡迎的程式語言，在 2023 年的調查也毫不意外的再度奪冠。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ewN57VU.png&quot; alt=&quot;Rust no1&quot;&gt;&lt;/p&gt;

&lt;p&gt;許多公司紛紛將 Rust 應用在產品上，例如：Amazon、Meta、Microsoft、Google 這些大公司，並且帶起一股似乎什麼都可以用 Rust 來重新改寫的風潮。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/xVLtmSH.png&quot; alt=&quot;rewrite it in rust&quot;&gt;&lt;/p&gt;

&lt;p&gt;既然 Rust 這麼猛，那麼是不是也可以運用在網頁開發上呢？答案是肯定的，現在已經有許多的框架可以用來開發，想開發前端沒問題，後端框架更是如雨後春筍般的冒出來，例如：Rocket、Actix、Warp、Tide 等等。&lt;/p&gt;

&lt;h2 id=&quot;javascript-rust&quot;&gt;從 JavaScript 的角度學習 Rust&lt;/h2&gt;

&lt;p&gt;身為網頁開發者，多多少少都會使用 JavaScript，所以從 JavaScript 的角度來學習 Rust 會比較容易理解。&lt;/p&gt;

&lt;h3 id=&quot;part-2c6052bd075b5c0e&quot;&gt;宣告變數&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;let x = 5; // mutable
const y = 10; // constant
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let x = 5; // immutable
let mut y = 10; // mutable
const Z: i32 = 15; // constant
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 使用 &lt;code&gt;let&lt;/code&gt; 宣告可變變數，而 &lt;code&gt;const&lt;/code&gt; 用於宣告常數。
Rust 默認使用 &lt;code&gt;let&lt;/code&gt; 宣告不可變變數，需要加 &lt;code&gt;mut&lt;/code&gt; 關鍵字來宣告可變變數。&lt;code&gt;const&lt;/code&gt; 在 Rust 中也用於宣告常數，但需要明確指定型別，並且變數名稱為大寫。&lt;/p&gt;

&lt;h3 id=&quot;part-65429879565&quot;&gt;型別&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;let a = &quot;hello&quot;; // string
let b = 5; // number
let c = 3.14; // number
let d = true; // boolean
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let a: &amp;amp;str = &quot;hello&quot;; // 字串切片
let b: i32 = 5; // 數字 i32
let c: f64 = 3.14; // 浮點數 f64
let d: bool = true; // bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 是動態型別語言，所以它不需要在變數宣告時指定型別。
Rust 是靜態型別語言，通常會在變數宣告時指定型別，但 Rust 的型別推斷也很強大，可以在多數情況下自動判斷型別，所以以這個例子來說，Rust 的型別宣告可以省略。&lt;/p&gt;

&lt;h3 id=&quot;part-6542802d35e&quot;&gt;函式&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function calculate(x, y) {
  return x + y;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn calculate(x: i32, y: i32) -&amp;gt; i32 {
  x + y
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 JavaScript 中，使用 &lt;code&gt;function&lt;/code&gt; 關鍵字定義函式。
在 Rust 中，使用 &lt;code&gt;fn&lt;/code&gt; 關鍵字定義函式，並在參數和返回值時指定型別。
補充一下說明，Rust 的函式可以省略 &lt;code&gt;return&lt;/code&gt;，最後一行的運算式會自動當作返回值，並且可以省略分號。&lt;/p&gt;

&lt;h3 id=&quot;if-else&quot;&gt;if...else&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;if (x &amp;gt; y) {
  console.log(&quot;x 大於 y&quot;);
} else {
  console.log(&quot;x 不大於 y&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;if x &amp;gt; y {
  println!(&quot;x 大於 y&quot;);
} else {
  println!(&quot;x 不大於 y&quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這兩種語言的 if...else 結構在語法上很相似，但 Rust 不需要括號來包裹條件語句。補充一下， JavaScript 的 &lt;code&gt;console.log&lt;/code&gt; 在 Rust 中等同是 &lt;code&gt;println!&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;part-65432f2b5e9&quot;&gt;迴圈&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;for (let i = 0; i &amp;lt; 10; i++) {
  console.log(`i is ${i}`);
}

while (x &amp;lt; 10) {
  console.log(`x is ${x}`);
  x+=1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;for i in 0..10 {
  println!(&quot;i is {}&quot;, i);
}

while x &amp;lt; 10 {
  println!(&quot;x is {}&quot;, x);
  x+=1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;兩種語言的迴圈語法也很相似，但在 Rust 中，&lt;code&gt;for in&lt;/code&gt; 用於遍歷範圍或集合。補充一下，在 Rust 的 &lt;code&gt;println!&lt;/code&gt; 中，&lt;code&gt;{}&lt;/code&gt; 用於格式化輸出，&lt;code&gt;{}&lt;/code&gt; 會被變數的值取代。所以這個 &lt;code&gt;for&lt;/code&gt; 例子出來的結果會是 &lt;code&gt;i is 0&lt;/code&gt; 到 &lt;code&gt;i is 9&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;part-2e77907a852ede12&quot;&gt;錯誤處理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;function divide(x, y) {
  if (y === 0) {
    throw new Error(&quot;無法除以 0&quot;);
  }
  return x / y;
}

try {
  const result = divide(10, 0);
  console.log(result);
} catch (e) {
  console.log(e.message);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn divide(x: i32, y: i32) -&amp;gt; Result&amp;lt;i32, String&amp;gt; {
  if y == 0 {
    return Err(&quot;無法除以 0&quot;.to_string());
  }
  Ok(x / y)
}

match divide(10, 0) {
  Ok(result) =&amp;gt; println!(&quot;{}&quot;, result),
  Err(e) =&amp;gt; println!(&quot;{}&quot;, e),
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;JavaScript 使用 &lt;code&gt;throw&lt;/code&gt; 和 &lt;code&gt;try...catch&lt;/code&gt; 來處理異常。
Rust 則使用 &lt;code&gt;Result&lt;/code&gt; enum 來表示可能的錯誤，並使用 &lt;code&gt;match&lt;/code&gt; 語句來處理這些結果。&lt;/p&gt;

&lt;h3 id=&quot;modules&quot;&gt;modules&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;// calc.js
function calculate(x, y) {
  return x + y;
}

export default calculate;

// index.js
import calculate from &quot;./calc.js&quot;;

console.log(calculate(5, 10));
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;// calc.rs
pub fn calculate(x: i32, y: i32) -&amp;gt; i32 {
  x + y
}

// main.rs
mod calc;
use calc::calculate;

fn main() {
  println!(&quot;{}&quot;, calculate(5, 10));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 JavaScript 中，您可以使用 &lt;code&gt;export&lt;/code&gt; 和 &lt;code&gt;import&lt;/code&gt; 來管理模組。
Rust 使用 &lt;code&gt;mod&lt;/code&gt; 關鍵字來聲明模組，並使用 &lt;code&gt;use&lt;/code&gt; 關鍵字來引入它。公開的函式或結構需要使用 &lt;code&gt;pub&lt;/code&gt; 關鍵字。&lt;/p&gt;

&lt;h2 id=&quot;tide&quot;&gt;如何使用 Tide&lt;/h2&gt;

&lt;p&gt;首先建立一個新專案:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cargo new tide_crud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;並且安裝相關的套件：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;[package]
name = &quot;tide_crud&quot;
version = &quot;0.1.0&quot;
edition = &quot;2021&quot;

# See more keys and their definitions at https://doc.rust-lang.org/cargo/reference/manifest.html

[dependencies]
tide = { version = &quot;0.16.0&quot; }
tokio = { version = &quot;1.29.1&quot;, features = [&quot;full&quot;] } // 非同步處理
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] } // 將資料轉換各種格式，例如 JSON、YAML、XML 等
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;安裝方法就是直接在 &lt;code&gt;Cargo.toml&lt;/code&gt; 中 &lt;code&gt;dependencies&lt;/code&gt; 底下加入 &lt;code&gt;tide&lt;/code&gt;、&lt;code&gt;tokio&lt;/code&gt; 和 &lt;code&gt;serde&lt;/code&gt; 這三個套件，然後只要一執行 &lt;code&gt;cargo run&lt;/code&gt; 就會自動安裝。&lt;/p&gt;

&lt;h3 id=&quot;hello-world&quot;&gt;Hello World&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use tide::{Request, Result};

async fn hello(_req: Request&amp;lt;()&amp;gt;) -&amp;gt; Result&amp;lt;String&amp;gt; {
    Ok(&quot;Hello, world!&quot;.to_string())
}

#[tokio::main]

async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    let mut app = tide::new();
    app.at(&quot;/&quot;).get(hello);
    app.listen(&quot;0.0.0.0:8080&quot;).await?;
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來只要執行 &lt;code&gt;cargo run -q&lt;/code&gt;，瀏覽器打開 &lt;code&gt;http://localhost:8080&lt;/code&gt; 就可以看到 &lt;code&gt;Hello, world!&lt;/code&gt;。&lt;/p&gt;

&lt;h3 id=&quot;part-2cc29d4a21d7eeec&quot;&gt;查詢參數&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use tide::{Request, Result, new};

async fn handle_name(req: Request&amp;lt;()&amp;gt;) -&amp;gt; Result&amp;lt;String&amp;gt; {
    let name = req
        .url()
        .query_pairs()
        .find(|(key, _)| key == &quot;name&quot;)
        .map(|(_, value)| value)
        .unwrap_or(&quot;world&quot;.into());

    Ok(format!(&quot;Hello, {}!&quot;, name))
}

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    let mut app = new();
    app.at(&quot;/&quot;).get(handle_name);
    app.listen(&quot;0.0.0.0:8080&quot;).await?;
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個例子展示了如何從 URL 中獲取查詢參數。如果提供了 name 查詢參數，它將用於回應，否則預設為 &quot;world&quot;。&lt;/p&gt;

&lt;h3 id=&quot;json&quot;&gt;JSON 處理&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use tide::{Request, Result, new};

#[derive(serde::Deserialize)]
struct Rust {
    name: String,
    version: f32,
}

async fn create(mut req: Request&amp;lt;()&amp;gt;) -&amp;gt; Result&amp;lt;String&amp;gt; {
    let rust: Rust = req.body_json().await?;
    Ok(format!(&quot;Hello {}! Your Rust version is {}.&quot;, rust.name, rust.version))
}

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    let mut app = new();
    app.at(&quot;/rust&quot;).post(create);
    app.listen(&quot;0.0.0.0:8080&quot;).await?;
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這裡展示了如何使用 Tide 處理 JSON 資料。當你向 &lt;code&gt;/rust&lt;/code&gt; 路徑發送 POST 請求並提供正確的 JSON 資料時，伺服器將回傳一個格式化的訊息。&lt;/p&gt;

&lt;p&gt;這個例子，假如在 Postman 輸入以下資料：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;{
    &quot;name&quot;: &quot;Bucky&quot;,
    &quot;version&quot;: 1.8
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;則會回傳：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hello Bucky! Your Rust version is 1.8.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;part-2c91238211f1da0f&quot;&gt;巢狀路由&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use tide::{Request, Result, new};

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    let mut app = new();
    app.at(&quot;/rust&quot;).nest({
        let mut api = new();
        api.at(&quot;/&quot;).post(|_req: Request&amp;lt;()&amp;gt;| async move { Ok(&quot;Create&quot;) });
        api.at(&quot;/:id&quot;)
            .get(|_req: Request&amp;lt;()&amp;gt;| async move { Ok(&quot;Read&quot;) });
        api.at(&quot;/version&quot;).get(|_req: Request&amp;lt;()&amp;gt;| async move { Ok(&quot;1.0.0&quot;) });

        api
    });
    app.listen(&quot;0.0.0.0:8080&quot;).await?;
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個例子展示了如何使用巢狀路由來組織你的應用程式。nest 方法允許你在一個給定的路徑下建立多個路由。&lt;/p&gt;

&lt;h3 id=&quot;status-code&quot;&gt;status code&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use tide::{new, Request, Response, Result, StatusCode};

async fn create(_req: Request&amp;lt;()&amp;gt;) -&amp;gt; Result {
    let res = Response::builder(StatusCode::Created)
        .body(&quot;Hello, world!&quot;)
        .build();
    Ok(res)
}

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    let mut app = new();
    app.at(&quot;/rust&quot;).post(create);
    app.listen(&quot;0.0.0.0:8080&quot;).await?;
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個例子展示了如何使用 Tide 處理 status code。&lt;/p&gt;

&lt;p&gt;如果要使用自定義的 status code，則在 &lt;code&gt;Response::new()&lt;/code&gt; 時，參數傳入自定義的 status code 即可，例如：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;let mut res = Response::new(200);
res.set_body(&quot;Hello, world!&quot;);
Ok(res)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;file-server&quot;&gt;file server&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use tide::{Result, new};

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    let mut app = new();
    app.at(&quot;/file.txt&quot;).serve_file(&quot;src/hello.txt&quot;)?;
    app.at(&quot;/test&quot;).serve_dir(&quot;./www&quot;)?;
    app.listen(&quot;0.0.0.0:8080&quot;).await?;
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個例子展示了如何使用 Tide 來處理靜態檔案。&lt;/p&gt;

&lt;h3 id=&quot;logger&quot;&gt;logger&lt;/h3&gt;

&lt;p&gt;先安裝 &lt;code&gt;femme&lt;/code&gt; 套件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml&quot;&gt;[dependencies]
femme = &quot;2.2.1&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use tide::{Result, new, log};

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
    femme::start();
    let mut app = new();
    app.with(log::LogMiddleware::new());
    app.at(&quot;/&quot;).get(|_| async {
        Ok(&quot;Hello, world!&quot;)
    });
    app.listen(&quot;0.0.0.0:8080&quot;).await?;
    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;透過 femme 在啟動伺服器後，每當有任何請求，在終端機中，就可以看到有關這次請求的日誌資訊。&lt;/p&gt;

&lt;h3 id=&quot;crud-api&quot;&gt;建立 CRUD API&lt;/h3&gt;

&lt;h4 id=&quot;model&quot;&gt;建立 model&lt;/h4&gt;

&lt;p&gt;先新增一個 &lt;code&gt;models.rs&lt;/code&gt; 檔案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use std::collections::HashMap;

#[derive(serde::Deserialize, serde::Serialize)]
pub struct User {
    pub id: u32,
    pub name: String,
    pub email: String,
}

pub struct Repository {
    pub users: HashMap&amp;lt;u32, User&amp;gt;,
}

impl Repository {
  pub fn new() -&amp;gt; Self {
    Self {
      users: HashMap::new(),
    }
  }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在這個 &lt;code&gt;models.rs&lt;/code&gt; 檔案中，定義了一個名為 &lt;code&gt;User&lt;/code&gt; 的結構體，代表一個用戶，以及一個名為 &lt;code&gt;Repository&lt;/code&gt; 的結構體，代表用戶的儲存庫。&lt;code&gt;Repository&lt;/code&gt; 使用 &lt;code&gt;HashMap&lt;/code&gt; 來儲存 &lt;code&gt;User&lt;/code&gt; 實例，其中用戶的 ID 作為 key。&lt;/p&gt;

&lt;h4 id=&quot;controller&quot;&gt;建立 controller&lt;/h4&gt;

&lt;p&gt;再新增一個 &lt;code&gt;controller.rs&lt;/code&gt; 檔案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use crate::models::{Repository, User};
use tide::{Body, Request, Result, StatusCode};
use std::sync::Arc;
use tokio::sync::RwLock;

type State = Arc&amp;lt;RwLock&amp;lt;Repository&amp;gt;&amp;gt;;

pub async fn create(mut req: Request&amp;lt;State&amp;gt;) -&amp;gt; Result {
    let user: User = req.body_json().await?;
    let state = req.state();
    let mut repo = state.write().await;

    repo.users.insert(user.id, user);

    Ok(StatusCode::Ok.into())
}

pub async fn read(req: Request&amp;lt;State&amp;gt;) -&amp;gt; Result {
    let state = req.state();
    let repo = &amp;amp;state.read().await;

    Ok(Body::from_json(&amp;amp;repo.users)?.into())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;controller.rs&lt;/code&gt; 檔案中，定義了幾個控制器函數，這些函數是用來處理 Web 請求的。這裡定義了 &lt;code&gt;create&lt;/code&gt; 和 &lt;code&gt;read&lt;/code&gt; 函數，分別用於新增和讀取。&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;create：從請求的 JSON 主體中獲取用戶資料，然後添加到儲存庫中。&lt;/li&gt;
&lt;li&gt;read：從儲存庫中獲取所有用戶的資料，然後以 JSON 格式返回。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;main-rs-create-read&quot;&gt;在 main.rs 中使用 create &amp;amp; read&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;mod models;
mod controller;

use std::sync::Arc;
use tide::Result;
use tokio::sync::RwLock;
use models::Repository;
use controller::{create, read};

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
  femme::start();
  let state = Arc::new(RwLock::new(Repository::new()));
  let mut app = tide::with_state(state);
  app.at(&quot;/users&quot;).post(create);
  app.at(&quot;/users&quot;).get(read);
  app.listen(&quot;0.0.0.0:8080&quot;).await?;
  Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;main.rs&lt;/code&gt; 中，首先引入之前定義的模型和控制器，並建立了一個新的儲存庫並將其儲存在共享狀態中。然後定義了路由以處理使用者的新增與讀取操作。&lt;/p&gt;

&lt;h4 id=&quot;update-delete&quot;&gt;update &amp;amp; delete&lt;/h4&gt;

&lt;p&gt;在 &lt;code&gt;controller.rs&lt;/code&gt; 中新增以下程式碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;pub async fn update(mut req: Request&amp;lt;State&amp;gt;) -&amp;gt; Result {
    let id: u32 = req.param(&quot;id&quot;)?.parse()?;
    let user: User = req.body_json().await?;
    let state = req.state();
    let mut repo = state.write().await;

    if repo.users.contains_key(&amp;amp;id) {
        repo.users.insert(id, user);
        Ok(StatusCode::Ok.into())
    } else {
        Ok(StatusCode::NotFound.into())
    }
}

pub async fn delete(req: Request&amp;lt;State&amp;gt;) -&amp;gt; Result {
    let id: u32 = req.param(&quot;id&quot;)?.parse()?;
    let state = req.state();
    let mut repo = state.write().await;

    if repo.users.contains_key(&amp;amp;id) {
        repo.users.remove(&amp;amp;id);
        Ok(StatusCode::Ok.into())
    } else {
        Ok(StatusCode::NotFound.into())
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;在 &lt;code&gt;controller.rs&lt;/code&gt; 添加兩個新的控制器函數：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;update：更新具有指定 ID 的用戶的資料。如果用戶存在，則更新其資料；否則，返回 404 Not Found。&lt;/li&gt;
&lt;li&gt;delete：刪除具有指定 ID 的用戶。如果用戶存在，則從儲存庫中刪除它；否則，返回 404 Not Found。&lt;/li&gt;
&lt;/ul&gt;

&lt;h4 id=&quot;main-rs-update-delete&quot;&gt;在 main.rs 中使用 update &amp;amp; delete&lt;/h4&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use controller::{create, read, update, delete};

#[tokio::main]
async fn main() -&amp;gt; Result&amp;lt;()&amp;gt; {
  femme::start();
  let state = Arc::new(RwLock::new(Repository::new()));
  let mut app = tide::with_state(state);
  app.at(&quot;/users&quot;).post(create);
  app.at(&quot;/users&quot;).get(read);
  app.at(&quot;/users/:id&quot;).put(update);
  app.at(&quot;/users/:id&quot;).delete(delete);
  app.listen(&quot;0.0.0.0:8080&quot;).await?;
  Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後在 &lt;code&gt;main.rs&lt;/code&gt; 加入新的路由以使用上面定義的 &lt;code&gt;update&lt;/code&gt; 和 &lt;code&gt;delete&lt;/code&gt; 控制器函數。這樣就可以建立完一個完整的 CRUD API。&lt;/p&gt;

&lt;h2 id=&quot;part-6542bd861e6&quot;&gt;心得&lt;/h2&gt;

&lt;p&gt;感謝這次 COSCUP 所有的工作人員，沒有你們的協助，讓我有這次寶貴的機會並且順利完成這次分享，也要特別感謝 nukr 大大幫我主持，沒想過會這麼多人參加，謝謝大家的支持，希望大家都有獲得一些東西回去。(感謝 Patty 一路陪我並幫我拍照)&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/JiNUdaE.jpg&quot; alt=&quot;20230806171203&quot;&gt;&lt;/p&gt;

&lt;p&gt;讓我炫耀一下被 Rust 大神 Luca Palmieri 發文的&lt;a href=&quot;https://twitter.com/algo_luca/status/1685487697580969984&quot;&gt;推特&lt;/a&gt;：
&lt;img src=&quot;https://i.imgur.com/si8mVlN.png&quot; alt=&quot;20230806171749&quot;&gt;&lt;/p&gt;

&lt;p&gt;最後有興趣的可以看一下當天的&lt;a href=&quot;https://gamma.app/public/Rust-Web--0a2uen43e3soifp&quot;&gt;簡報分享&lt;/a&gt;&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sun, 06 Aug 2023 16:52:40 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-web.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 7 minutes</category>
    </item>
    <item>
      <title>淺談在 2023 年的 React 還需要 Redux 嗎？</title>
      <link>https://railquill.vercel.app/2023-react-redux.html</link>
      <description>淺談在 2023 年的 React 還需要 Redux 嗎？</description>
      <content:encoded><![CDATA[
        &lt;h1 id=&quot;2023-react-redux&quot;&gt;淺談在 2023 年的 React 還需要 Redux 嗎？&lt;/h1&gt;

&lt;p&gt;前幾天在推特上看到有人提問標題這個問題，有些網友回覆 Redux 太複雜，建議改用其他的狀態管理套件。也有網友提出 React 都有 context API 來處理跨元件狀態了，根本不需要 Redux。&lt;/p&gt;

&lt;p&gt;在這個問題上，許多開發者可能會有不同的觀點，但讓我們先從最基本的 React context 開始比較，然後再探討 Redux。&lt;/p&gt;

&lt;p&gt;首先，我們來看看 React 的 context API。React context 提供了一種方式來共享值，例如這些值是全域的，例如主題、語言偏好等等，而不需要手動將 &lt;code&gt;props&lt;/code&gt; 傳遞過多層。然而，當我們使用 &lt;code&gt;useContext&lt;/code&gt; 並搭配 &lt;code&gt;useReducer&lt;/code&gt; 來作為全域狀態管理時，所有使用該 context 的元件將會在 state 變更時重新 render，不論他們使用的 state 部分是否有改變。如果你有一個沒有被 &lt;code&gt;useCallback&lt;/code&gt; 包裹的處理器，那麼虛擬 DOM 比對將會失敗，這些元件將會導致 DOM 更新。當然你可以有多個小的 contexts，但這樣你就會有多個狀態的來源，這可能還是得根據你的需求和實作方式來判別這樣是好是壞。&lt;/p&gt;

&lt;p&gt;另一方面，Redux 提供了一個集中式和預測性的 state 容器，讓你可以在整個應用程式中管理狀態。儘管在引入 hooks 和 context API 之後，React 提供了一種方式來在組件之間共享狀態，但 Redux 仍然有其價值。Redux 的主要優勢在於它的嚴謹的更新邏輯：所有的狀態更新都被集中處理並通過 actions 和 reducers 來描述。這種方法提供了很高的可預測性和一致性，這在複雜的應用程式中是很有價值的。&lt;/p&gt;

&lt;p&gt;不過 Redux 出了名困難的學習曲線，對於開發者來說也是一個望而卻步的門檻。我之前也寫了一篇介紹 Redux 的文章，有興趣的朋友可以看我之前的&lt;a href=&quot;https://bucky0112.github.io/2022/03/10/libraries-redux/&quot;&gt;這篇文章&lt;/a&gt;去看看。&lt;/p&gt;

&lt;p&gt;為了解決這個問題，Redux 也推出了 Redux Toolkit(RTK) 來進一步簡化 Redux 的使用。RTK 是 Redux 的官方工具集，其主要目標是解決 Redux 過於複雜的問題，並且提供了一組工具來協助你更簡單地寫 Redux，所以開發者可以寫出更精簡、更可讀的 Redux 代碼，並且有更好的開發者體驗。&lt;/p&gt;

&lt;p&gt;RTK 提供了 &lt;code&gt;configureStore()&lt;/code&gt; 函數來建立 store，這比過去的 &lt;code&gt;createStore()&lt;/code&gt; 提供了更多的好處。&lt;code&gt;configureStore()&lt;/code&gt; 會自動添加非同步的能力，並且支援 &lt;a href=&quot;https://chrome.google.com/webstore/detail/redux-devtools/lmhkpmbekcpmknklioeibfkpmmfibljd&quot;&gt;Redux Devtools Extension&lt;/a&gt;，這可以讓開發者在瀏覽器開發者工具輕鬆看到狀態的變更，當然還有其他的好處，例如我們不再需要 &lt;code&gt;combineReducers()&lt;/code&gt;，以下是用 RTK 所做的一個簡單的範例：&lt;/p&gt;



&lt;p&gt;因此，儘管 React 的 context 提供了簡易的方式來處理跨元件的狀態，但從上面的 RTK 的範例來看，在不失去原本 Redux 強大的狀態管理之下，卻簡化了很多繁複的設定。&lt;/p&gt;

&lt;h2 id=&quot;part-6542fd4e95a&quot;&gt;結論&lt;/h2&gt;

&lt;p&gt;React Context API 是一種非常有效的工具，它可以處理許多跨元件的狀態共享問題。然而，對於大型或複雜的應用程式來說，Redux 提供的集中式狀態管理能力可能會更適合。尤其是當你需要更嚴謹的狀態更新邏輯，或是與其他工具（例如 Redux DevTools）的搭配時。&lt;/p&gt;

&lt;p&gt;而 Redux Toolkit 是 Redux 的現代化版本，它簡化了 Redux 的許多繁複部分，並加入了許多有用的功能，例如自動處理 action 和 reducer 的創建、處理異步邏輯和狀態的不可變性。因此，對於需要複雜狀態管理且尋求簡化開發體驗的專案，Redux Toolkit 是一個很好的選擇。&lt;/p&gt;

&lt;p&gt;總的來說，選擇使用 Redux 或是 React Context，或是其他的狀態管理工具，應該基於你的專案需求，並考慮到每種工具的優缺點。在某些情況下，Redux 提供的嚴謹的狀態管理和健全的開發者工具可能是必要的；而在其他情況下，React Context 的輕量級和靈活性可能就足夠了。所以，在你選擇工具的時候，最重要的是理解你的專案需求和這些工具的適用情境。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sat, 20 May 2023 11:27:10 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/2023-react-redux.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 1 minutes</category>
    </item>
    <item>
      <title>React Native x Expo x TypeScript 實作計算機</title>
      <link>https://railquill.vercel.app/react-native-x-expo-x-typescript.html</link>
      <description>讓我們來用 React Native 和 Expo，還有 TypeScript 來寫一個計算機手機 App 吧！</description>
      <content:encoded><![CDATA[
        &lt;p&gt;讓我們來用 React Native 和 Expo，還有 TypeScript 來寫一個計算機手機 App 吧！&lt;/p&gt;

&lt;h2 id=&quot;react-native&quot;&gt;什麼是 React Native?&lt;/h2&gt;

&lt;p&gt;React Native 是一個用於構建移動應用程序的 JavaScript 框架。可以讓開發者使用 ReactJS 為 iOS 和 Android 平台創建手機 App。 React Native 提供了一套預構建的組件，可以用來構建應用程序的用戶界面，使得創建移動應用程序變得快速而簡單。&lt;/p&gt;

&lt;h2 id=&quot;expo&quot;&gt;什麼是 Expo?&lt;/h2&gt;

&lt;p&gt;Expo 是一套用於構建和部署 React Native 應用程序的工具和服務。它為開發者提供了一個平台，可以在各種設備和平台上輕鬆設置、運行和測試他們的 React Native 應用。 Expo 還提供了一系列的 library 和 API，可用於為應用程序添加功能，如照相、推送通知等。&lt;/p&gt;

&lt;h2 id=&quot;part-2caaddad57c9f7a8&quot;&gt;建立專案&lt;/h2&gt;

&lt;p&gt;首先來建立專案，如果這個專案取名為 &lt;code&gt;calculator&lt;/code&gt;，那麼就執行以下指令：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npx create-expo-app calculator --template
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;因為我們要使用 TypeScript，所以我們要選擇 &lt;code&gt;blank (TypeScript)&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;安裝如果沒問題的話，就會顯示以下訊息：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;✅ Your project is ready!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來就進入專案目錄後，啟動專案：&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;expo start
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後按下 &lt;code&gt;i&lt;/code&gt;，就會打開 iOS 模擬器，如果要使用 Android 的話，就按下 &lt;code&gt;a&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/bbrxsxO.png&quot; alt=&quot;20230218021734&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;part-b021db5f8bc2840&quot;&gt;安裝樣式套件&lt;/h2&gt;

&lt;p&gt;因為我覺得 React Native 的樣式寫起來很麻煩，而且已經很習慣 TailwindCSS 了，所以我們要安裝 &lt;code&gt;NativeWind&lt;/code&gt; 這個套件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;yarn add nativewind
yarn add --dev tailwindcss
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接下來我們要建立 &lt;code&gt;tailwind.config.js&lt;/code&gt; 這個檔案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;npx tailwindcss init
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;module.exports = {
  content: [&quot;./App.{js,jsx,ts,tsx}&quot;, &quot;./&amp;lt;custom directory&amp;gt;/**/*.{js,jsx,ts,tsx}&quot;],
  theme: {
    extend: {},
  },
  plugins: [],
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;並且在 &lt;code&gt;babel.config.js&lt;/code&gt; 中加入 plugin：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;module.exports = function (api) {
  api.cache(true);
  return {
    presets: [&quot;babel-preset-expo&quot;],
+   plugins: [&quot;nativewind/babel&quot;],
  };
};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後來測試一下是否有安裝成功&lt;/p&gt;

&lt;p&gt;這是原本的 App.tsx:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;tsx&quot;&gt;import { StatusBar } from &#39;expo-status-bar&#39;;
import { StyleSheet, Text, View } from &#39;react-native&#39;;

export default function App() {
  return (
    &amp;lt;View style={styles.container}&amp;gt;
      &amp;lt;Text&amp;gt;Open up App.tsx to start working on your app!&amp;lt;/Text&amp;gt;
      &amp;lt;StatusBar style=&quot;auto&quot; /&amp;gt;
    &amp;lt;/View&amp;gt;
  );
}

const styles = StyleSheet.create({
  container: {
    flex: 1,
    backgroundColor: &#39;#fff&#39;,
    alignItems: &#39;center&#39;,
    justifyContent: &#39;center&#39;,
  },
});
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我們把 &lt;code&gt;styles&lt;/code&gt; 拿掉，並改成 &lt;code&gt;className&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;tsx&quot;&gt;import { StatusBar } from &#39;expo-status-bar&#39;
import { Text, View } from &#39;react-native&#39;

export default function App() {
  return (
    &amp;lt;View className=&#39;flex-1  items-center justify-center bg-white&#39;&amp;gt;
      &amp;lt;Text&amp;gt;Open up App.tsx to start working on your app!&amp;lt;/Text&amp;gt;
      &amp;lt;StatusBar style=&#39;auto&#39; /&amp;gt;
    &amp;lt;/View&amp;gt;
  )
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後眼尖的你可能會發現到，在 &lt;code&gt;className&lt;/code&gt; 下會出現紅色的線。不用擔心，官網有提到如何解決這個問題，只要再新增一個 &lt;code&gt;app.d.ts&lt;/code&gt; 檔案就可以了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;ts&quot;&gt;/// &amp;lt;reference types=&quot;nativewind/types&quot; /&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;上面的部分是 TypeScript 才需要做的步驟，如果你是用 JavaScript 的話，就不需要做這個步驟。&lt;/p&gt;

&lt;p&gt;接下來會分成：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;建立重複使用的元件&lt;/li&gt;
&lt;li&gt;計算的邏輯撰寫&lt;/li&gt;
&lt;li&gt;整合成完整 App&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&quot;part-a5a5653468a905b6&quot;&gt;建立重複使用的元件&lt;/h2&gt;

&lt;h3 id=&quot;part-6542a95fd26&quot;&gt;按鈕&lt;/h3&gt;

&lt;p&gt;首先因為計算機有很多按鈕，所以我們要建立一個重複使用的元件，這樣就不用每次都要寫一個按鈕。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;tsx&quot;&gt;import {
  Text,
  TouchableOpacity,
  TextProps,
  TouchableOpacityProps,
} from &#39;react-native&#39;
import classNames from &#39;classnames&#39;

type ClickButtonProps = TouchableOpacityProps &amp;amp; {
  text: string
  size?: &#39;double&#39;
  theme?: &#39;primary&#39; | &#39;secondary&#39; | &#39;accent&#39;
  textProps?: TextProps
}

const ClickButton = ({
  onPress,
  text,
  size,
  theme = &#39;primary&#39;,
  textProps,
  ...rest
}: ClickButtonProps) =&amp;gt; {


  return (
    &amp;lt;TouchableOpacity
      onPress={onPress}
      className={classNames({
        &quot;rounded-full flex-1 items-center justify-center m-2&quot;: true,
        &quot;h-[84px]&quot;: true,
        &quot;w-[84px]&quot;: true,
        &#39;w-full&#39;: size === &#39;double&#39;,
        &#39;bg-primary-btn&#39;: theme === &#39;primary&#39;,
        &#39;bg-secondary-btn&#39;: theme === &#39;secondary&#39;,
        &#39;bg-accent-btn&#39;: theme === &#39;accent&#39;
      })}
      {...rest}
      testID=&#39;click-button&#39;
    &amp;gt;
      &amp;lt;Text
        className={classNames({
          &#39;text-3xl font-bold text-center&#39;: true,
          &#39;text-white&#39;: theme === &#39;secondary&#39; || theme === &#39;primary&#39;,
        })}
        {...textProps}
      &amp;gt;
        {text}
      &amp;lt;/Text&amp;gt;
    &amp;lt;/TouchableOpacity&amp;gt;
  )
}

export { ClickButton }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;我們先建立一個自定義的 &lt;code&gt;ClickButton&lt;/code&gt; 元件。&lt;/p&gt;

&lt;p&gt;首先 &lt;code&gt;ClickButtonProps&lt;/code&gt; 需要繼承來 React Native 的 &lt;code&gt;TouchableOpacityProps&lt;/code&gt;，並增加一些自己的 props 型別，包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;text：按鈕上顯示的文字。&lt;/li&gt;
&lt;li&gt;size：按鈕的大小，為可選的 double，默認為按鈕的標準大小。&lt;/li&gt;
&lt;li&gt;theme：按鈕的主題，為可選的 &#39;primary&#39;、&#39;secondary&#39; 或 &#39;accent&#39;，默認為 &#39;primary&#39;。&lt;/li&gt;
&lt;li&gt;textProps：文字元件的 props，用於按鈕上文字的樣式。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;這個元件使用了 React Native 提供的 &lt;code&gt;TouchableOpacity&lt;/code&gt; 原生元件，可以把它當成 Web 中的 &lt;code&gt;&amp;lt;button /&amp;gt;&lt;/code&gt;，然後我們傳遞了一些 props。這些 props 包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;onPress：當按鈕被點擊時觸發的回調函數。&lt;/li&gt;
&lt;li&gt;className：應用在 TouchableOpacity 元件上的樣式類。&lt;/li&gt;
&lt;li&gt;...rest：傳遞所有其餘的 props 到 TouchableOpacity 元件中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;此外，&lt;code&gt;ClickButton&lt;/code&gt; 元件也使用了一個 React Native &lt;code&gt;Text&lt;/code&gt; 元件，可以當成 &lt;code&gt;&amp;lt;p /&amp;gt;&lt;/code&gt;。我們用於顯示按鈕上的文字，並傳遞了一些 props。這些 props 包括：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;className：應用在 Text 元件上的樣式類。&lt;/li&gt;
&lt;li&gt;...textProps：傳遞所有其餘的 props 到 Text 元件中。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;最後，&lt;code&gt;classNames&lt;/code&gt; 這個套件可以幫助我們來判斷條件，並且跟 TailwindCSS 搭配使用，可以讓我們更方便的撰寫樣式。&lt;/p&gt;

&lt;h3 id=&quot;row&quot;&gt;Row&lt;/h3&gt;

&lt;p&gt;接下來我們要建立一個 Row 元件，用於顯示按鈕的排列方式。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;tsx&quot;&gt;import { View } from &#39;react-native&#39;

type RowProps = {
  children: React.ReactNode;
};

const Row = ({ children, ...rest }: RowProps) =&amp;gt; {
  return (
    &amp;lt;View className=&#39;flex-row items-center gap-1&#39; {...rest}&amp;gt;
      {children}
    &amp;lt;/View&amp;gt;
  )
}

export { Row }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這個部分就比較簡單，一樣自定義一個 &lt;code&gt;Row&lt;/code&gt; 元件。&lt;/p&gt;

&lt;p&gt;然後 TypeScript 一樣都先起手式定義型別，&lt;code&gt;RowProps&lt;/code&gt; 定義了一個必需的 children，用於渲染元件內的子元素。是一個 React Node，可以是一個或多個 React 元素。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;Row&lt;/code&gt; 使用了 React Native 的 &lt;code&gt;View&lt;/code&gt; 元件，可以把它當成 &lt;code&gt;&amp;lt;div /&amp;gt;&lt;/code&gt; 來看。&lt;/p&gt;

&lt;p&gt;然後 &lt;code&gt;View&lt;/code&gt; 的樣式排列方式預設是用 Flexbox，並且是垂直排列，所以我們要將它改成水平排列。&lt;/p&gt;

&lt;h2 id=&quot;part-52fffbbdd600e02&quot;&gt;計算的邏輯撰寫&lt;/h2&gt;

&lt;p&gt;這個部分非常重要，因為是主要的功能邏輯。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;tsx&quot;&gt;export type State = {
  currentValue: string
  operator: string | null
  previousValue: string | null
}

export const initialState: State = {
  currentValue: &#39;0&#39;,
  operator: null,
  previousValue: null
}

export const handleNumber = (value: string, state: State): State =&amp;gt; {
  return {
    ...state,
    currentValue:
      state.currentValue === &#39;0&#39; ? `${value}` : `${state.currentValue}${value}`
  }
}

const handleEqual = (state: State): State =&amp;gt; {
  const { currentValue, previousValue = &#39;0&#39;, operator } = state

  const current = parseFloat(currentValue)
  const previous = parseFloat(previousValue as string)
  const resetState = { operator: null, previousValue: null }

  switch (operator) {
    case &#39;+&#39;:
      return {
        ...resetState,
        currentValue: `${previous + current}`
      }
    case &#39;-&#39;:
      return {
        ...resetState,
        currentValue: `${previous - current}`
      }
    case &#39;*&#39;:
      return {
        ...resetState,
        currentValue: `${previous * current}`
      }
    case &#39;/&#39;:
      return {
        ...resetState,
        currentValue: `${previous / current}`
      }
    default:
      return state
  }
}

const calculator = (type: string, value: string, state: State): State =&amp;gt; {
  switch (type) {
    case &#39;number&#39;:
      return handleNumber(value, state)
    case &#39;clear&#39;:
      return initialState
    case &#39;toggleSign&#39;:
      return {
        ...state,
        currentValue: `${parseFloat(state.currentValue) * -1}`
      }
    case &#39;percentage&#39;:
      return {
        ...state,
        currentValue: `${parseFloat(state.currentValue) * 0.01}`
      }
    case &#39;operator&#39;:
      return {
        operator: value,
        previousValue: state.currentValue,
        currentValue: &#39;0&#39;
      }
    case &#39;equal&#39;:
      return handleEqual(state)
    default:
      return state
  }
}

export default calculator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;主要建立一個函式 &lt;code&gt;calculator&lt;/code&gt; 和一個物件 &lt;code&gt;State&lt;/code&gt;。&lt;code&gt;State&lt;/code&gt; 描述了計算機的當前狀態，而 &lt;code&gt;calculator&lt;/code&gt; 則用於處理不同的操作並更新 &lt;code&gt;State&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;State&lt;/code&gt; 描述了計算機當前的狀態，包含三個屬性：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;currentValue：用於記錄當前的輸入值或計算結果。&lt;/li&gt;
&lt;li&gt;operator：用於記錄當前的運算符號。&lt;/li&gt;
&lt;li&gt;previousValue：用於記錄上一個輸入值或計算結果。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;initialState&lt;/code&gt; 用於初始化 &lt;code&gt;State&lt;/code&gt;，將 &lt;code&gt;currentValue&lt;/code&gt; 設置為 &#39;0&#39;，將 &lt;code&gt;operator&lt;/code&gt; 和 &lt;code&gt;previousValue&lt;/code&gt; 設置為 null。&lt;/p&gt;

&lt;p&gt;而 &lt;code&gt;handleNumber&lt;/code&gt; 用於處理數字輸入操作，接受兩個參數：一個字串 &lt;code&gt;value&lt;/code&gt;，表示輸入的數字；一個 &lt;code&gt;State&lt;/code&gt; 物件，表示當前的狀態。當處理數字輸入操作時，&lt;code&gt;handleNumber&lt;/code&gt; 函數會將 &lt;code&gt;currentValue&lt;/code&gt; 更新為當前的輸入值。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;handleEqual&lt;/code&gt; 函式用於處理等於的操作，接受一個 &lt;code&gt;State&lt;/code&gt; 物件作為參數。當處理等於操作時，&lt;code&gt;handleEqual&lt;/code&gt; 會根據當前的運算符號計算當前的表達式，並返回新的 &lt;code&gt;State&lt;/code&gt;，其中 &lt;code&gt;currentValue&lt;/code&gt; 被設置為計算結果。如果當前沒有運算符號，則直接返回當前的狀態。&lt;/p&gt;

&lt;p&gt;&lt;code&gt;calculator&lt;/code&gt; 函式接受三個參數：一個字串 &lt;code&gt;type&lt;/code&gt;，表示當前的操作類型；一個字串 &lt;code&gt;value&lt;/code&gt;，表示當前的操作值；一個 &lt;code&gt;State&lt;/code&gt; 物件，表示當前的狀態。根據不同的操作類型，&lt;code&gt;calculator&lt;/code&gt; 會判斷不同的處理方式，從而更新 &lt;code&gt;State&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在這個簡單的計算機中，我們只實現了一些基本的操作，有加、減、乘、除、清除、正負號切換和百分比轉換等。並且使用了 &lt;code&gt;parseFloat&lt;/code&gt; 將輸入值轉換為浮點數。&lt;/p&gt;

&lt;h2 id=&quot;part-2de8710d384304ef&quot;&gt;組裝元件&lt;/h2&gt;

&lt;p&gt;最後我們把我們的元件跟邏輯都組裝起來，就可以使用了。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;tsx&quot;&gt;import { useState, useCallback } from &#39;react&#39;
import { SafeAreaView, Text, View } from &#39;react-native&#39;
import { ClickButton, Row } from &#39;./src/components&#39;
import calculator, { initialState, State } from &#39;./src/util/calculator&#39;

const App = () =&amp;gt; {
  const [state, setState] = useState&amp;lt;State&amp;gt;(initialState)

  const handleTap = useCallback((type: string, value: string | number) =&amp;gt; {
    const valueString = typeof value === &#39;number&#39; ? String(value) : value
    setState((prevState) =&amp;gt; calculator(type, valueString, prevState))
  }, [])

  return (
    &amp;lt;View className=&#39;flex-1 justify-end bg-[#202020] px-2&#39;&amp;gt;
      &amp;lt;SafeAreaView&amp;gt;
        &amp;lt;View className=&#39;items-end pr-4 pb-4&#39;&amp;gt;
          &amp;lt;Text className=&#39;text-white text-6xl font-bold&#39;&amp;gt;
            {parseFloat(state.currentValue).toLocaleString()}
          &amp;lt;/Text&amp;gt;
        &amp;lt;/View&amp;gt;

        &amp;lt;Row&amp;gt;
          &amp;lt;ClickButton
            text=&#39;C&#39;
            theme=&#39;secondary&#39;
            onPress={() =&amp;gt; handleTap(&#39;clear&#39;, &#39;&#39;)}
          /&amp;gt;
          &amp;lt;ClickButton
            text=&#39;+/-&#39;
            theme=&#39;secondary&#39;
            onPress={() =&amp;gt; handleTap(&#39;toggleSign&#39;, &#39;&#39;)}
          /&amp;gt;
          &amp;lt;ClickButton
            text=&#39;%&#39;
            theme=&#39;secondary&#39;
            onPress={() =&amp;gt; handleTap(&#39;percentage&#39;, &#39;&#39;)}
          /&amp;gt;
          &amp;lt;ClickButton
            text=&#39;/&#39;
            theme=&#39;accent&#39;
            onPress={() =&amp;gt; handleTap(&#39;operator&#39;, &#39;/&#39;)}
          /&amp;gt;
        &amp;lt;/Row&amp;gt;

        &amp;lt;Row&amp;gt;
          &amp;lt;ClickButton text=&#39;7&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;7&#39;)} /&amp;gt;
          &amp;lt;ClickButton text=&#39;8&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;8&#39;)} /&amp;gt;
          &amp;lt;ClickButton text=&#39;9&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;9&#39;)} /&amp;gt;
          &amp;lt;ClickButton
            text=&#39;X&#39;
            theme=&#39;accent&#39;
            onPress={() =&amp;gt; handleTap(&#39;operator&#39;, &#39;*&#39;)}
          /&amp;gt;
        &amp;lt;/Row&amp;gt;

        &amp;lt;Row&amp;gt;
          &amp;lt;ClickButton text=&#39;5&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;5&#39;)} /&amp;gt;
          &amp;lt;ClickButton text=&#39;6&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;6&#39;)} /&amp;gt;
          &amp;lt;ClickButton text=&#39;7&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;7&#39;)} /&amp;gt;
          &amp;lt;ClickButton
            text=&#39;-&#39;
            theme=&#39;accent&#39;
            onPress={() =&amp;gt; handleTap(&#39;operator&#39;, &#39;-&#39;)}
          /&amp;gt;
        &amp;lt;/Row&amp;gt;

        &amp;lt;Row&amp;gt;
          &amp;lt;ClickButton text=&#39;1&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;1&#39;)} /&amp;gt;
          &amp;lt;ClickButton text=&#39;2&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;2&#39;)} /&amp;gt;
          &amp;lt;ClickButton text=&#39;3&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;3&#39;)} /&amp;gt;
          &amp;lt;ClickButton
            text=&#39;+&#39;
            theme=&#39;accent&#39;
            onPress={() =&amp;gt; handleTap(&#39;operator&#39;, &#39;+&#39;)}
          /&amp;gt;
        &amp;lt;/Row&amp;gt;

        &amp;lt;Row&amp;gt;
          &amp;lt;ClickButton text=&#39;0&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;0&#39;)} /&amp;gt;
          &amp;lt;ClickButton text=&#39;.&#39; onPress={() =&amp;gt; handleTap(&#39;number&#39;, &#39;.&#39;)} /&amp;gt;
          &amp;lt;ClickButton
            text=&#39;=&#39;
            theme=&#39;primary&#39;
            onPress={() =&amp;gt; handleTap(&#39;equal&#39;, &#39;=&#39;)}
          /&amp;gt;
        &amp;lt;/Row&amp;gt;
      &amp;lt;/SafeAreaView&amp;gt;
    &amp;lt;/View&amp;gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;整個 &lt;code&gt;App&lt;/code&gt; 在渲染時，會將當前的 &lt;code&gt;state.currentValue&lt;/code&gt; 作為計算機的顯示欄位，這個值會使用 &lt;code&gt;parseFloat&lt;/code&gt; 和 &lt;code&gt;toLocaleString&lt;/code&gt; 將輸入值轉換為具有千分位的字串。&lt;/p&gt;

&lt;p&gt;接著，&lt;code&gt;App&lt;/code&gt; 使用了多個 &lt;code&gt;ClickButton&lt;/code&gt; 元件，這些元件封裝了不同的操作，如清除、正負號切換、百分比轉換、加、減、乘、除等操作。這些元件通過 &lt;code&gt;onPress&lt;/code&gt; 屬性綁定了對應的處理函式，當按鈕被點擊時，會調用 &lt;code&gt;handleTap&lt;/code&gt; 進行處理。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;handleTap&lt;/code&gt; 函式中，將操作參數 &lt;code&gt;type&lt;/code&gt;、&lt;code&gt;value&lt;/code&gt;，並調用 &lt;code&gt;calculator&lt;/code&gt; 函式進行計算，並使用 &lt;code&gt;useState&lt;/code&gt; 的 &lt;code&gt;setState&lt;/code&gt; 來更新當前的狀態。&lt;/p&gt;

&lt;p&gt;最後的執行畫面像這樣：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/alhteFF.png&quot; alt=&quot;20230224005423&quot;&gt;&lt;/p&gt;

&lt;p&gt;如果想要看完整的程式碼，可以到 &lt;a href=&quot;https://github.com/bucky0112/calculator_expo&quot;&gt;Repo&lt;/a&gt; 看看。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Fri, 24 Feb 2023 00:58:20 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/react-native-x-expo-x-typescript.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 6 minutes</category>
    </item>
    <item>
      <title>React.js 全攻略班推薦給想要精進自我的前端工程師</title>
      <link>https://railquill.vercel.app/react-js.html</link>
      <description>這門課程是由五倍紅寶石舉辦，並由奶綠茶老師教導，這門課程對於想要精進自我的前端工程師來說，是一個非常好的選擇。</description>
      <content:encoded><![CDATA[
        &lt;p&gt;&lt;img src=&quot;https://i.imgur.com/OqxEqG8.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

&lt;p&gt;作為一名前端工程師，由於在日常工作中經常使用 React.js，而且也非常地喜愛這個前端框架。所以，為了更加了解 React.js，並且能更精進自我，我決定選擇了「&lt;a href=&quot;https://5xruby.tw/courses/react&quot;&gt;React.js 全攻略 - 入門到進階&lt;/a&gt;」這門課程，由五倍紅寶石舉辦，並由奶綠茶老師教導。&lt;/p&gt;

&lt;h2 id=&quot;part-d65b72ba877c1bf7&quot;&gt;為什麼選擇這門課？&lt;/h2&gt;

&lt;p&gt;為什麼選擇上這門課？首先是因為我本身對 React.js的興趣，希望在這門課中學到更多的知識。其次，五倍紅寶石在業界十分著名，師資團隊一字排開都是業界的大神，也都擁有豐富的教學經驗，因此我對這門課非常感興趣，也覺得可以為我的職涯帶來幫助。&lt;/p&gt;

&lt;h2 id=&quot;part-12ee13b3b43d2c9d&quot;&gt;這門課帶給我什麼幫助&lt;/h2&gt;

&lt;p&gt;在這門課中，我學到了很多實用的知識。老師會由簡入深帶領我們一步一步學習，老師自己也準備許多有趣並且實際運用的專案。平常一些覺得枯燥乏味的部分，在幽默風趣的奶綠茶老師講解後，也都覺得非常的生動活潑。例如 React.js 元件的生命週期、處理資料與狀態管理等。這些知識不僅讓我更加了解 React.js，也知道了一些程式碼底層如何運作，對於 React.js 有非常深刻的了解。&lt;/p&gt;

&lt;p&gt;除此之外，奶綠茶老師也教導我們一些在開發實戰的經驗與技巧，還有如何讓 React 能夠更節省效能。
例如，我學到了如何實現 React.js 元件的 lazy loading，以提高網頁的載入速度，還有運用 useMemo 和 useCallback 來優化網頁的渲染。&lt;/p&gt;

&lt;p&gt;老師除了教導各個 React.js Hooks 的使用以外，同時也與時俱進地更新 React.js 版本，React.js 18 更新了什麼都講解的非常地仔細。而在狀態管理部分，奶綠茶老師也教我們如何使用 Context API 來處理資料與狀態管理，還有使用知名開源套件 Redux，這對我在工作中實現組件間的資料共享和狀態管理有很大的幫助。&lt;/p&gt;

&lt;p&gt;除此之外，這門課還教授了 React.js 開發的最佳實踐，例如如何設計優秀的 React.js 元件和如何使用 RReact.js Router 來實現頁面路由。最後也一再強調測試對於開發的重要性，教我們該怎麼使用 Jest 和 React Testing Library 來測試。&lt;/p&gt;

&lt;h2 id=&quot;x&quot;&gt;感謝 x 五倍&lt;/h2&gt;

&lt;p&gt;最後，我要感謝五倍紅寶石。在這門課中，我不僅學到了很多知識，也在一個輕鬆愉快的環境中享受到了學習的樂趣。我對五倍紅寶石的教學團隊表示敬意，每當我有任何疑問想要詢問時，課務人員都會非常有耐心，並且不厭其煩地回答我的任何有關課業上的問題，非常感謝他們為我提供了如此寶貴的學習機會。&lt;/p&gt;

&lt;p&gt;我深刻地體驗到了五倍紅寶石對學生的關心和支持，因此我強烈推薦五倍紅寶石的課程給所有對前端開發有興趣的人。如果你對 React 有興趣的話，那麼 React 全攻略是一門不可錯過的課程，不管是剛入門或是資深的工程師，它都會為你提供更多有用的知識和實踐經驗。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/AFxtIV3.jpg&quot; alt=&quot;&quot;&gt;&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Wed, 15 Feb 2023 11:04:32 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/react-js.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 1 minutes</category>
    </item>
    <item>
      <title>使用 Jest 和 React Testing Library 進行測試的方法 - 測試列表</title>
      <link>https://railquill.vercel.app/jest-react-testing-library.html</link>
      <description>介紹如何使用 Jest 和 React Testing Library 進行測試列表</description>
      <content:encoded><![CDATA[
        &lt;h2 id=&quot;part-654280cbc50&quot;&gt;前言&lt;/h2&gt;

&lt;p&gt;本文將涵蓋測試列表、測試列表內容、以及測試 App 元件。我們依然會使用 Jest + React Testing Library 來實現測試。&lt;/p&gt;

&lt;h2 id=&quot;part-2d4bccd877a4e33b&quot;&gt;測試列表&lt;/h2&gt;

&lt;p&gt;接下來接續上一篇未完成的測試，我們來測試一個列表的元件，這個元件會接收一個陣列，並且將陣列中的每個元素渲染成一個列表項目。&lt;/p&gt;

&lt;p&gt;如果不想翻到上一篇文章，可以直接看這個 Demo。&lt;/p&gt;



&lt;p&gt;那麼首先在測試之前，要先來看一下這個元件預期會怎麼呈現。&lt;/p&gt;

&lt;p&gt;預期會透過 props 傳來一個 &lt;code&gt;users&lt;/code&gt; 這個陣列，並且將陣列中的每個元素渲染成一個列表項目。&lt;/p&gt;

&lt;p&gt;必須要確保是否正確呈現列表項目，所以我們可以這麼寫測試：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import { render, screen, within } from &#39;@testing-library/react&#39;
import List from &quot;./List&quot;

test(&#39;it renders a list of users&#39;, () =&amp;gt; {
  const users = [
    { name: &#39;John Doe&#39; },
    { name: &#39;Jane Doe&#39; }
  ]

  render(&amp;lt;List users={users} /&amp;gt;)

  const list = within(screen.getByTestId(&#39;users&#39;)).getAllByRole(&#39;listitem&#39;)
  expect(list).toHaveLength(2)
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先我們先模擬一個 &lt;code&gt;users&lt;/code&gt; 陣列的資料，並且將資料傳入到 &lt;code&gt;List&lt;/code&gt; 元件中。&lt;/p&gt;

&lt;p&gt;接著我們要知道 &lt;code&gt;List&lt;/code&gt; 是不是正確渲染出來，我們到這個步驟可以先到 &lt;code&gt;List&lt;/code&gt; 元件的 &lt;code&gt;ul&lt;/code&gt; 標籤中加上 &lt;code&gt;data-testid=&quot;users&quot;&lt;/code&gt; 這個屬性，這樣我們就可以透過 &lt;code&gt;screen.getByTestId(&#39;users&#39;)&lt;/code&gt; 來取得這個元素。&lt;/p&gt;

&lt;p&gt;然後就可以透過 &lt;code&gt;within&lt;/code&gt; 函式來取得 &lt;code&gt;ul&lt;/code&gt; 標籤中的所有 &lt;code&gt;li&lt;/code&gt; 標籤，並且透過 &lt;code&gt;getAllByRole&lt;/code&gt; 來取得 &lt;code&gt;li&lt;/code&gt; 標籤中的所有 &lt;code&gt;listitem&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;最後就可以透過 &lt;code&gt;toHaveLength&lt;/code&gt; 來確認陣列的長度是否正確。&lt;/p&gt;

&lt;h2 id=&quot;part-3911f5ba6422af18&quot;&gt;測試列表內容&lt;/h2&gt;

&lt;p&gt;這裡我們要來測試是不是有正確顯示內容，預期應該是要顯示名字出來。&lt;/p&gt;

&lt;p&gt;然後因為應該會使用到一樣的模擬資料，所以我們可以先把上一個測試的 &lt;code&gt;users&lt;/code&gt; 陣列抽出來，並且將它放在 &lt;code&gt;renderComponent&lt;/code&gt; 函式中。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const renderComponent = () =&amp;gt; {
  const users = [{ name: &#39;john doe&#39; }, { name: &#39;jane doe&#39; }]

  render(&amp;lt;List users={users} /&amp;gt;)

  return { users }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著放入測試中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;test(&#39;it renders the user name&#39;, () =&amp;gt; {
  const { users } = renderComponent()
  users.forEach((user, index) =&amp;gt; {
    const name = screen.getByTestId(`name-${index}`)
    expect(name).toBeInTheDocument()
  })
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先通過呼叫 &lt;code&gt;renderComponent&lt;/code&gt; 函式呈現元件，並使用 &lt;code&gt;forEach&lt;/code&gt; 函式跑一遍用戶列表，並使用 &lt;code&gt;screen.getByTestId&lt;/code&gt; 函式查找具有 &quot;data-testid&quot; 屬性為 &quot;name-index&quot; 的元素，並使用 &lt;code&gt;index&lt;/code&gt; 來當用戶的索引。&lt;/p&gt;

&lt;p&gt;最後，通過使用 &lt;code&gt;toBeInTheDocument&lt;/code&gt; 函式驗證元素是否存在，確認每個用戶的 &lt;code&gt;name&lt;/code&gt; 是不是正確地呈現。&lt;/p&gt;

&lt;h2 id=&quot;app&quot;&gt;測試 App&lt;/h2&gt;

&lt;p&gt;最後，不要忘記還有 &lt;code&gt;App.js&lt;/code&gt; 這個元件，因為裡面會是預設的測試內容，但我們已經有加入了兩個元件，所以現在跑測試的話，會發現 &lt;code&gt;App.js&lt;/code&gt; 這個元件會失敗。&lt;/p&gt;

&lt;p&gt;這個測試比較像是整合測試，因為我們要確認 &lt;code&gt;App.js&lt;/code&gt; 這個元件是否正確地將 &lt;code&gt;List&lt;/code&gt; 的內容和 &lt;code&gt;Form&lt;/code&gt; 的動作呈現出來。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import { render, screen } from &#39;@testing-library/react&#39;;
import user from &quot;@testing-library/user-event&quot;;
import App from &#39;./App&#39;;

test(&#39;can receive a new user and show it on a list&#39;, () =&amp;gt; {
  render(&amp;lt;App /&amp;gt;)

  const nameInput = screen.getByRole(&quot;textbox&quot;, { name: /name/i })
  const button = screen.getByRole(&quot;button&quot;);

  user.click(nameInput);
  user.keyboard(&quot;John Doe&quot;);
  user.click(button);


  const name = screen.getByTestId(&quot;name-0&quot;, { name: &quot;John Doe&quot; })
  expect(name).toBeInTheDocument()
})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先使用 &lt;code&gt;screen.getByRole&lt;/code&gt; 函式查找具有 &quot;role&quot; 屬性 &quot;textbox&quot; 且名稱包含 &quot;name&quot; 的元素，並將其儲存在 &lt;code&gt;nameInput&lt;/code&gt; 變數中。&lt;/p&gt;

&lt;p&gt;接下來，使用 &lt;code&gt;screen.getByRole&lt;/code&gt; 函式查找具有 &quot;role&quot; 屬性 &quot;button&quot; 的元素，並將其儲存在 &lt;code&gt;button&lt;/code&gt; 變數中。&lt;/p&gt;

&lt;p&gt;然後，使用 &lt;code&gt;user.click&lt;/code&gt; 函式模擬對 &lt;code&gt;nameInput&lt;/code&gt; 元素的點擊，並使用 &lt;code&gt;user.keyboard&lt;/code&gt; 函式向其中鍵入 &quot;John Doe&quot;。&lt;/p&gt;

&lt;p&gt;接下來，使用 &lt;code&gt;user.click&lt;/code&gt; 函式模擬對 &lt;code&gt;button&lt;/code&gt; 元素的點擊。&lt;/p&gt;

&lt;p&gt;最後，使用 &lt;code&gt;screen.getByTestId&lt;/code&gt; 函式查找具有 &quot;data-testid&quot; 屬性 &quot;name-0&quot; 且名稱為 &quot;John Doe&quot; 的元素，並使用 &lt;code&gt;toBeInTheDocument&lt;/code&gt; 函式驗證其是否在文件中存在。&lt;/p&gt;

&lt;p&gt;以上就是簡單的展示一下如何測試 React 元件，感謝閱讀。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sat, 11 Feb 2023 15:12:51 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/jest-react-testing-library.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 2 minutes</category>
    </item>
    <item>
      <title>Rust x React</title>
      <link>https://railquill.vercel.app/rust-x-react.html</link>
      <description>Rust x React 夢幻共演</description>
      <content:encoded><![CDATA[
        &lt;p&gt;終於到最後一天了，看到&lt;a href=&quot;https://www.cnblogs.com/yjmyzz/p/how-to-create-a-react-app-with-rust-and-wasm.html&quot;&gt;這篇文章&lt;/a&gt;覺得很有趣，所以今天我們來玩一下 Rust 跟 React 的結合吧！&lt;/p&gt;

&lt;h2 id=&quot;part-2ea806877d406032&quot;&gt;開始專案&lt;/h2&gt;

&lt;p&gt;首先我們先建立一個新的專案，這邊我們使用 create-react-app 來建立一個新的專案，並且使用 yarn 來安裝相依套件。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ yarn create react-app rust-react
$ cd rust-react
$ yarn
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&quot;rust&quot;&gt;建立 Rust&lt;/h2&gt;

&lt;p&gt;接下來我們在專案中建立一個 Rust 的 library：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cargo new wasm-lib --lib
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後會在專案中看到一個 wasm-lib 的資料夾，裡面會有一個 &lt;code&gt;src&lt;/code&gt; 資料夾，裡面會有一個 &lt;code&gt;lib.rs&lt;/code&gt; 的檔案，這個檔案就是我們的 Rust library。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/AUNRQuP.png&quot; alt=&quot;CleanShot 2022-10-11 at 17.18.51&quot;&gt;&lt;/p&gt;

&lt;p&gt;因為我們預計想要做一個可以點擊加減的按鈕，然後回傳計算結果，所以我們可以在 &lt;code&gt;lib.rs&lt;/code&gt; 中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;pub fn calculator(a: i32, b: i32) -&amp;gt; i32 {
    a + b
}

#[test]
fn cal_test() {
    assert_eq!(1 + 1, calculator(1, 1));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後 cd 到 &lt;code&gt;wasm-lib&lt;/code&gt; 資料夾，並且測試一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cd wasm-lib
$ cargo test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;沒什麼問題的話，就會出現以下的結果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/CdjJOch.png&quot; alt=&quot;CleanShot 2022-10-11 at 17.25.42&quot;&gt;&lt;/p&gt;

&lt;p&gt;接下來到 &lt;code&gt;Cargo.toml&lt;/code&gt; 中加入以下的設定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml&quot;&gt;[lib]
crate-type = [&quot;cdylib&quot;]

[dependencies]
wasm-bindgen = &quot;0.2.78&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這一段的意思是，我們要把這個 library 轉換成 WebAssembly 的格式，並且使用 wasm-bindgen 來幫我們轉換。&lt;/p&gt;

&lt;p&gt;然後還要在 &lt;code&gt;src/lib.rs&lt;/code&gt; 中加入設定：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use wasm_bindgen::prelude::*;

#[wasm_bindgen]
pub fn calculator(a: i32, b: i32) -&amp;gt; i32 {
    a + b
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣可以讓 &lt;code&gt;calculator&lt;/code&gt; 這個函式可以在 wasm 中被使用。&lt;/p&gt;

&lt;p&gt;接下來我們要安裝 wasm-pack：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cargo install wasm-pack
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後我們還需要讓 Rust 可以在這個專案中可以運作。
所以在 &lt;code&gt;package.json&lt;/code&gt; 中加入 script:&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;json&quot;&gt;&quot;scripts&quot;: {
  &quot;start&quot;: &quot;react-scripts start&quot;,
  &quot;build&quot;: &quot;react-scripts build&quot;,
  &quot;test&quot;: &quot;react-scripts test&quot;,
  &quot;eject&quot;: &quot;react-scripts eject&quot;,
  &quot;build:wasm&quot;: &quot;cd wasm-lib &amp;amp;&amp;amp; wasm-pack build --target web --out-dir pkg&quot;
},
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ yarn build:wasm
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後就會生成一個 &lt;code&gt;pkg&lt;/code&gt; 的資料夾，裡面會有一個 &lt;code&gt;wasm_lib_bg.wasm&lt;/code&gt; 的檔案，這就是我們的 WebAssembly 檔案。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/O6rvmyB.png&quot; alt=&quot;CleanShot 2022-10-11 at 17.50.36@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;並且我們可以看到我們剛剛建立的 &lt;code&gt;calculator&lt;/code&gt; 函式已經生成在 &lt;code&gt;wasm_lib.d.ts&lt;/code&gt; 中了。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/TbRxl8D.png&quot; alt=&quot;CleanShot 2022-10-11 at 18.00.17@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後我們還需要把他加進 &lt;code&gt;node_modules&lt;/code&gt; 中，所以我們要在終端機中執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ yarn add ./wasm-lib/pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣就可以在 &lt;code&gt;node_modules&lt;/code&gt; 中看到 &lt;code&gt;wasm-lib&lt;/code&gt; 這個資料夾了，並且我們可以引入來使用他。&lt;/p&gt;

&lt;p&gt;最後我們來 React 中使用他：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;jsx&quot;&gt;import { useState } from &#39;react&#39;
import init, { calculator } from &#39;wasm-lib&#39;
import logo from &#39;./logo.svg&#39;
import &#39;./App.css&#39;

function App() {
  const [num, setNum] = useState(0)

  const handlePlus = () =&amp;gt; {
    init().then(() =&amp;gt; {
      setNum(calculator(num, 1))
    })
  }

  const handleMinus = () =&amp;gt; {
    if (num &amp;gt; 0) {
      init().then(() =&amp;gt; {
        setNum(calculator(num, -1))
      })
    }
  }

  return (
    &amp;lt;div className=&#39;App&#39;&amp;gt;
      &amp;lt;header className=&#39;App-header&#39;&amp;gt;
        &amp;lt;img src={logo} className=&#39;App-logo&#39; alt=&#39;logo&#39; /&amp;gt;
        &amp;lt;p&amp;gt;{num}&amp;lt;/p&amp;gt;
        &amp;lt;div&amp;gt;
          &amp;lt;button onClick={handlePlus}&amp;gt;+&amp;lt;/button&amp;gt;
          &amp;lt;button onClick={handleMinus}&amp;gt;-&amp;lt;/button&amp;gt;
        &amp;lt;/div&amp;gt;
      &amp;lt;/header&amp;gt;
    &amp;lt;/div&amp;gt;
  )
}

export default App
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後執行 &lt;code&gt;yarn start&lt;/code&gt;，就可以執行我們的專案，並且讓 Rust 運行在 React 中了。&lt;/p&gt;

&lt;h2 id=&quot;part-2bb94ba078f5a9ec&quot;&gt;同場加映&lt;/h2&gt;

&lt;p&gt;前面只是單純的使用 Rust 來做加減的動作，但是這樣看不出 Rust 的效能優勢，所以我們來做一些稍微複雜的運算玩玩看。&lt;/p&gt;

&lt;p&gt;我們來做一個費氏數列的函式，並且使用 Rust 來做運算。&lt;/p&gt;

&lt;p&gt;首先在 &lt;code&gt;wasm-lib/src/lib.rs&lt;/code&gt; 中加入新的方法，並且寫一下測試：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[wasm_bindgen]
pub fn fibonacci(n: i32) -&amp;gt; i32 {
    if n &amp;lt;= 1 {
        return n;
    } else {
        return fibonacci(n - 1) + fibonacci(n - 2);
    }
}

#[test]
fn fib_test() {
    assert_eq!(1, fibonacci(1));
    assert_eq!(1, fibonacci(2));
    assert_eq!(2, fibonacci(3));
    assert_eq!(3, fibonacci(4));
    assert_eq!(5, fibonacci(5));
    assert_eq!(8, fibonacci(6));
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;跑一下測試，執行：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;// 在 wasm-lib 資料夾中
$ cargo test
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/E6huTQ5.png&quot; alt=&quot;CleanShot 2022-10-14 at 17.50.57@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;然後記得要重新 build：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;// 要在根目錄中執行
$ yarn build:wasm
$ yarn add ./wasm-lib/pkg
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後在 &lt;code&gt;App.js&lt;/code&gt; 加進我們的 &lt;code&gt;fibonacci&lt;/code&gt; 函式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;import init, { calculator, fibonacci } from &#39;wasm-lib&#39;

function App() {
  // 省略...
  const handleFibonacci = () =&amp;gt; {
    let start = new Date().getTime()
    init().then(() =&amp;gt; {
      setFibonacciNum(fibonacci(inputNum))
    })
    let end = new Date().getTime()
    console.log(`Rust: 時間： ${end - start} ms`)
  }
  // 省略...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後另外寫一個 JS 的費氏數列函式：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;js&quot;&gt;const calFibonacci = (n) =&amp;gt; {
  if (n &amp;lt;= 1) {
    return n
  } else {
    return calFibonacci(n - 1) + calFibonacci(n - 2)
  }
}

function App() {
  // 省略...
  const handleFibonacciJS = () =&amp;gt; {
    let start = new Date().getTime()
    let result = calFibonacci(inputNum)
    setFibonacciNumJS(result)
    let end = new Date().getTime()
    console.log(`JS: 時間： ${end - start} ms`)
  }
  // 省略...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後執行一下結果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gFcFkIx.gif&quot; alt=&quot;CleanShot 2022-10-15 at 01.02.46&quot;&gt;&lt;/p&gt;

&lt;p&gt;相信看到畫面，不用多說你應該也能感受到 Rust 的效能優勢了。&lt;/p&gt;

&lt;p&gt;如果有興趣的話，可以直接參考我的 &lt;a href=&quot;https://github.com/bucky0112/rust_x_react&quot;&gt;GitHub Repo&lt;/a&gt;。&lt;/p&gt;

&lt;h2 id=&quot;part-6542bd861e6&quot;&gt;心得&lt;/h2&gt;

&lt;p&gt;這 30 天真的滿辛苦的，每天都要硬擠出時間來寫文章，本來有跟朋友一起寫 side project 的行程，但因為時間不夠的關係，只好先跟朋友暫緩，真的是對他們非常抱歉。&lt;/p&gt;

&lt;p&gt;但是自己也覺得這 30 天真的學到很多東西，雖然寫到一半的時候，有點想要放棄，但是想到自己已經開始了，就不想要放棄，所以就繼續寫下去，最後也完成了。完賽的成就感真的是很棒，也讓我對自己的信心有了一點點的提升。&lt;/p&gt;

&lt;p&gt;然後 Rust 真的是一個很棒的語言，雖然我還沒有寫到很複雜的東西，但是我相信未來會有更多的機會可以使用 Rust，也希望自己能夠繼續學習下去。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/gCQstja.gif&quot; alt=&quot;ferris&quot;&gt;&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sat, 15 Oct 2022 01:50:59 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-x-react.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 3 minutes</category>
    </item>
    <item>
      <title>用 Rust 來寫前端 - Yew</title>
      <link>https://railquill.vercel.app/rust-yew.html</link>
      <description>Rust 的框架 Rocket</description>
      <content:encoded><![CDATA[
        &lt;p&gt;今天是我們一起學習 Rust 的第 29 天了，前面我們玩了很多後端的東西，今天我們來玩一下前端的東西吧！&lt;/p&gt;

&lt;h2 id=&quot;webassembly&quot;&gt;WebAssembly&lt;/h2&gt;

&lt;p&gt;在開始之前，想先介紹一下 WebAssembly，它是一種可以在瀏覽器中執行的程式語言，它可以讓我們在瀏覽器中執行非常複雜的程式，而且它的執行速度也非常快，所以我們可以在瀏覽器中執行一些比較複雜的運算，而不會影響到瀏覽器的體驗。&lt;/p&gt;

&lt;h2 id=&quot;yew&quot;&gt;Yew&lt;/h2&gt;

&lt;p&gt;&lt;a href=&quot;https://yew.rs/&quot;&gt;Yew&lt;/a&gt; 是一個可以讓我們在 Rust 中使用 WebAssembly 的框架，它可以讓我們在 Rust 中撰寫前端的程式，並且可以編譯成 WebAssembly，讓我們在瀏覽器中執行。&lt;/p&gt;

&lt;h2 id=&quot;yew&quot;&gt;安裝 Yew&lt;/h2&gt;

&lt;p&gt;那麼我們要如何使用 Yew 來開發前端的程式呢？按照官網的指示，我們要先安裝以下的東西：&lt;/p&gt;

&lt;h3 id=&quot;webassembly&quot;&gt;WebAssembly&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ rustup target add wasm32-unknown-unknown
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;trunk&quot;&gt;Trunk&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cargo install trunk
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;part-2ea8073161887627&quot;&gt;開新專案&lt;/h3&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cargo new yew-demo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後在 &lt;code&gt;Cargo.toml&lt;/code&gt; 中加入以下的內容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml&quot;&gt;[dependencies]
yew = &quot;0.19&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;到這邊我們就可以開始撰寫程式了！&lt;/p&gt;

&lt;p&gt;先在 &lt;code&gt;src/main.rs&lt;/code&gt; 中加入以下的內容：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use yew::prelude::*;

enum Msg {
    AddOne,
}

struct Model {
    value: i64,
}

impl Component for Model {
    type Message = Msg;
    type Properties = ();

    fn create(_ctx: &amp;amp;Context&amp;lt;Self&amp;gt;) -&amp;gt; Self {
        Self {
            value: 0,
        }
    }

    fn update(&amp;amp;mut self, _ctx: &amp;amp;Context&amp;lt;Self&amp;gt;, msg: Self::Message) -&amp;gt; bool {
        match msg {
            Msg::AddOne =&amp;gt; {
                self.value += 1;
                // the value has changed so we need to
                // re-render for it to appear on the page
                true
            }
        }
    }

    fn view(&amp;amp;self, ctx: &amp;amp;Context&amp;lt;Self&amp;gt;) -&amp;gt; Html {
        // This gives us a component&#39;s &quot;`Scope`&quot; which allows us to send messages, etc to the component.
        let link = ctx.link();
        html! {
            &amp;lt;div&amp;gt;
                &amp;lt;button onclick={link.callback(|_| Msg::AddOne)}&amp;gt;{ &quot;+1&quot; }&amp;lt;/button&amp;gt;
                &amp;lt;p&amp;gt;{ self.value }&amp;lt;/p&amp;gt;
            &amp;lt;/div&amp;gt;
        }
    }
}

fn main() {
    yew::start_app::&amp;lt;Model&amp;gt;();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後在根目錄下新增一個 &lt;code&gt;index.html&lt;/code&gt;：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;!DOCTYPE html&amp;gt;
&amp;lt;html&amp;gt;
  &amp;lt;head&amp;gt;
    &amp;lt;meta charset=&quot;utf-8&quot; /&amp;gt;
    &amp;lt;title&amp;gt;Yew App&amp;lt;/title&amp;gt;
  &amp;lt;/head&amp;gt;
&amp;lt;/html&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後執行 &lt;code&gt;trunk serve&lt;/code&gt;，就可以在瀏覽器中看到我們的網頁了！&lt;/p&gt;

&lt;p&gt;不過目前只能讓數字加 1，那我們再加另一個按鈕可以 - 1 看起來比較完整一點：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;enum Msg {
    AddOne,
    MinusOne,
}

impl Component for Model {
    // 省略..
        fn update(&amp;amp;mut self, _ctx: &amp;amp;Context&amp;lt;Self&amp;gt;, msg: Self::Message) -&amp;gt; bool {
        match msg {
            Msg::AddOne =&amp;gt; {
                self.value += 1;
                true
            }

            Msg::MinusOne =&amp;gt; {
                if (self.value &amp;gt; 0) {
                    self.value -= 1;
                }
                true
            }
        }
    }

    fn view(&amp;amp;self, ctx: &amp;amp;Context&amp;lt;Self&amp;gt;) -&amp;gt; Html {
        let link = ctx.link();
        html! {
            &amp;lt;div class=&quot;content&quot;&amp;gt;
                &amp;lt;button onclick={link.callback(|_| Msg::AddOne)} class=&quot;btn&quot;&amp;gt;{ &quot;+1&quot; }&amp;lt;/button&amp;gt;
                &amp;lt;p class=&quot;result&quot;&amp;gt;{ self.value }&amp;lt;/p&amp;gt;
                &amp;lt;button onclick={link.callback(|_| Msg::MinusOne)} class=&quot;btn&quot;&amp;gt;{ &quot;-1&quot; }&amp;lt;/button&amp;gt;
            &amp;lt;/div&amp;gt;
        }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;如果要順便加上一些 CSS 的話，可以在在根目錄新增一個 &lt;code&gt;style.css&lt;/code&gt;，然後在 &lt;code&gt;index.html&lt;/code&gt; 中加入：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;html&quot;&gt;&amp;lt;link data-trunk href=&quot;style.css&quot; rel=&quot;css&quot;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣就完成一個用 Yew 寫的 App 了！&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ibz0XCZ.gif&quot; alt=&quot;CleanShot 2022-10-14 at 00.21.36&quot;&gt;&lt;/p&gt;

&lt;p&gt;大家如果有興趣的話，可以參考我的 &lt;a href=&quot;https://github.com/bucky0112/yew_calculator&quot;&gt;GitHub repo&lt;/a&gt; 來玩玩看。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Fri, 14 Oct 2022 00:31:42 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-yew.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 2 minutes</category>
    </item>
    <item>
      <title>來玩 Rust 的框架吧！ - Rocket - Part III</title>
      <link>https://railquill.vercel.app/rust-rocket-part-iii.html</link>
      <description>Rust 的框架 Rocket</description>
      <content:encoded><![CDATA[
        &lt;p&gt;我們今天要來做 Auth，一個基本的身分驗證功能，不想要讓任何人都可以隨便使用我們的 API。&lt;/p&gt;

&lt;h2 id=&quot;part-2c5c0dcf475632bf&quot;&gt;安裝套件&lt;/h2&gt;

&lt;p&gt;因為我們驗證的處理會使用到 base64 編碼，所以首先我們先在 &lt;code&gt;Cargo.toml&lt;/code&gt; 加入 &lt;code&gt;base64&lt;/code&gt; 這個 crate。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml&quot;&gt;[dependencies]
base64 = &quot;0.13&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;由於目前 &lt;code&gt;main.rs&lt;/code&gt; 中的 code 有點多，所以我們另外開一個檔案來處理。
直接在 &lt;code&gt;src&lt;/code&gt; 資料夾下新增一個 &lt;code&gt;auth.rs&lt;/code&gt; 檔案，並且在 &lt;code&gt;main.rs&lt;/code&gt; 中加入 &lt;code&gt;mod auth;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;auth.rs&lt;/code&gt; 中我們先來定義一個 &lt;code&gt;BasicAuth&lt;/code&gt; 的 struct，並且在裡面定義一個使用者名稱和密碼的欄位。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;pub struct BasicAuth {
    username: String,
    password: String,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use rocket::http::Status;
use rocket::request::{Request, FromRequest, Outcome};

pub struct BasicAuth {
    pub username: String,
    pub password: String,
}
impl BasicAuth {
    fn from_authorization_header(header: &amp;amp;str) -&amp;gt; Option&amp;lt;BasicAuth&amp;gt; {
        let split = header.split_whitespace().collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();
        if split.len() != 2 {
            return None;
        }

        if split[0] != &quot;Basic&quot; {
            return None;
        }

        Self::from_base64_encoded(split[1])
    }

    fn from_base64_encoded(base64_string: &amp;amp;str) -&amp;gt; Option&amp;lt;BasicAuth&amp;gt; {
        let decoded = base64::decode(base64_string).ok()?;
        let decoded_str = String::from_utf8(decoded).ok()?;
        let split = decoded_str.split(&quot;:&quot;).collect::&amp;lt;Vec&amp;lt;_&amp;gt;&amp;gt;();

        // If exactly username &amp;amp; password pair are present
        if split.len() != 2 {
            return None;
        }

        let (username, password) = (split[0].to_string(), split[1].to_string());

        Some(BasicAuth {
            username,
            password
        })
    }
}

#[rocket::async_trait]
impl&amp;lt;&#39;r&amp;gt; FromRequest&amp;lt;&#39;r&amp;gt; for BasicAuth {
    type Error = ();

    async fn from_request(request: &amp;amp;&#39;r Request&amp;lt;&#39;_&amp;gt;) -&amp;gt; Outcome&amp;lt;Self, Self::Error&amp;gt; {
        let auth_header = request.headers().get_one(&quot;Authorization&quot;);
        if let Some(auth_header) = auth_header {
            if let Some(auth) = Self::from_authorization_header(auth_header) {
                return Outcome::Success(auth)
            }
        }

        Outcome::Failure((Status::Unauthorized, ()))
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著我們定義了一個 &lt;code&gt;from_authorization_header&lt;/code&gt; 的 function，這個 function 會接收一個 &lt;code&gt;header&lt;/code&gt; 的參數，並且回傳一個 &lt;code&gt;Option&amp;lt;BasicAuth&amp;gt;&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;主要是在處理 &lt;code&gt;Authorization&lt;/code&gt; 的 header，如果 header 的長度不是 2，或是 header 的第一個值不是 &lt;code&gt;Basic&lt;/code&gt;，就會回傳 &lt;code&gt;None&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;如果 header 的長度是 2，且第一個值是 &lt;code&gt;Basic&lt;/code&gt;，就會呼叫 &lt;code&gt;from_base64_encoded&lt;/code&gt; 這個 function，並且將 header 的第二個值傳入。&lt;/p&gt;

&lt;p&gt;然後 &lt;code&gt;from_base64_encoded&lt;/code&gt; 主要是將傳入的值進行 base64 解碼，並且轉成 &lt;code&gt;String&lt;/code&gt;，接著再將這個 &lt;code&gt;String&lt;/code&gt; 以 &lt;code&gt;:&lt;/code&gt; 進行分割，並且將分割後的值傳入 &lt;code&gt;BasicAuth&lt;/code&gt; 的 struct 中。&lt;/p&gt;

&lt;p&gt;最後我們定義了一個 &lt;code&gt;FromRequest&lt;/code&gt; 的 trait，這個 trait 會在我們的 API 被呼叫時，會先進行驗證，如果驗證成功，就會將驗證的結果傳入 API 中。&lt;/p&gt;

&lt;p&gt;在 &lt;code&gt;from_request&lt;/code&gt; 中，我們先取得 &lt;code&gt;Authorization&lt;/code&gt; 的 header，如果有的話，就會呼叫 &lt;code&gt;from_authorization_header&lt;/code&gt; 這個 function，並且將 header 傳入。&lt;/p&gt;

&lt;p&gt;如果驗證成功，就會回傳 &lt;code&gt;Outcome::Success(auth)&lt;/code&gt;，如果驗證失敗，就會回傳 &lt;code&gt;Outcome::Failure((Status::Unauthorized, ()))&lt;/code&gt;。&lt;/p&gt;

&lt;h2 id=&quot;api&quot;&gt;處理 API&lt;/h2&gt;

&lt;p&gt;接下來我們在 &lt;code&gt;main.rs&lt;/code&gt; 中加入我們剛剛所定義的 &lt;code&gt;BasicAuth&lt;/code&gt;。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;mod auth;

use auth::BasicAuth;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後先在 &lt;code&gt;get_demo&lt;/code&gt; 這個 API 中加入 &lt;code&gt;BasicAuth&lt;/code&gt; 的參數運作看看：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[get(&quot;/demo&quot;)]
fn get_demo(_auth: BasicAuth) -&amp;gt; Value {
    json!([{ &quot;id&quot;: 1, &quot;name&quot;: &quot;Bucky&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Tom&quot; }])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;執行完打開瀏覽器會發現頁面顯示 401 的錯誤，代表我們剛剛所做的驗證有開始運作，所以我們接著嘗試在 Postman 的 header 中加入 &lt;code&gt;Authorization&lt;/code&gt;。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/y36n1kN.png&quot; alt=&quot;CleanShot 2022-10-09 at 23.01.51@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;我們將 &lt;code&gt;Authorization&lt;/code&gt; 的值改成 &lt;code&gt;Basic YnVja3k6YnVja3k=&lt;/code&gt;，這個值是 &lt;code&gt;bucky:bucky&lt;/code&gt; 這個字串進行 base64 編碼後的結果，我們把這個值當成 token 來驗證之後就可以成功取得資料了。&lt;/p&gt;

&lt;p&gt;接著就可以在所有的 methods 都加上 &lt;code&gt;BasicAuth&lt;/code&gt;，這樣我們所有的 methods 都會進行驗證了。&lt;/p&gt;

&lt;h2 id=&quot;part-6542fd4e95a&quot;&gt;結論&lt;/h2&gt;

&lt;p&gt;目前我們已經知道怎麼做出一個簡單 CRUD 的 API，然後也知道怎麼做出一個簡單的驗證。而在剩下的參賽天數內，我們要來玩一下其他的部分，明天我們要來玩一下 Yew 這個 Rust 的前端框架。&lt;/p&gt;

&lt;p&gt;而 Rocket 建立的 API 部分，我們會在之後的文章繼續完成，會做到跟資料庫的連線，還有部署的部分，所以如果有興趣的話，再請大家拭目以待。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Thu, 13 Oct 2022 01:31:13 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-rocket-part-iii.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 2 minutes</category>
    </item>
    <item>
      <title>來玩 Rust 的框架吧！ - Rocket - Part II</title>
      <link>https://railquill.vercel.app/rust-rocket-part-ii.html</link>
      <description>Rust 的框架 Rocket</description>
      <content:encoded><![CDATA[
        &lt;p&gt;昨天我們用已經用 Rocket 建立了一個 server，並且可以接收回傳 JSON，今天就來了解一下怎麼使用 Rocket 建立一個 RESTful API。&lt;/p&gt;

&lt;h2 id=&quot;restful-api&quot;&gt;RESTful API&lt;/h2&gt;

&lt;p&gt;我們會建立一個簡單的 Restful API 的範例，分別會用到 &lt;code&gt;GET&lt;/code&gt;、&lt;code&gt;POST&lt;/code&gt;、&lt;code&gt;PUT&lt;/code&gt;、&lt;code&gt;DELETE&lt;/code&gt; 這四個 HTTP method，接下來我們就來看看怎麼實作。&lt;/p&gt;

&lt;p&gt;分別建立以下的函式，這邊使用 &lt;code&gt;#[get]&lt;/code&gt;、&lt;code&gt;#[post]&lt;/code&gt;、&lt;code&gt;#[put]&lt;/code&gt;、&lt;code&gt;#[delete]&lt;/code&gt; 來指定 HTTP method：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[get(&quot;/demo&quot;)]
fn get_demo() -&amp;gt; Value {
    json!([{ &quot;id&quot;: 1, &quot;name&quot;: &quot;Bucky&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Tom&quot; }])
}

#[get(&quot;/demo/&amp;lt;id&amp;gt;&quot;)]
fn view_demo(id: i32) -&amp;gt; Value {
    json!({ &quot;id&quot;: id, &quot;name&quot;: &quot;Some one&quot; })
}

#[post(&quot;/demo&quot;, format = &quot;json&quot;)]
fn create_demo() -&amp;gt; Value {
    json!({ &quot;id&quot;: 3, &quot;name&quot;: &quot;Patty&quot; })
}

#[put(&quot;/demo/&amp;lt;id&amp;gt;&quot;, format = &quot;json&quot;)]
fn update_demo(id: i32) -&amp;gt; Value {
    json!({ &quot;id&quot;: id, &quot;name&quot;: &quot;Bucky&quot; })
}

#[delete(&quot;/demo/&amp;lt;id&amp;gt;&quot;)]
fn delete_demo(id: i32) -&amp;gt; status::NoContent {
    status::NoContent
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;最後的 &lt;code&gt;delete_demo&lt;/code&gt; 應該會遇到編譯錯誤，因為我們沒有引入 &lt;code&gt;status&lt;/code&gt;，所以我們要加入 &lt;code&gt;use rocket::response::status;&lt;/code&gt;，這樣就可以正常編譯了。&lt;/p&gt;

&lt;p&gt;接下來我們還需要修改一下運作 &lt;code&gt;rocket&lt;/code&gt;，主要把我們建立的幾個 method 加進 &lt;code&gt;routes&lt;/code&gt; 中：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;fn rocket() -&amp;gt; _ {
    let routes = routes![get_demo, view_demo, create_demo, update_demo, delete_demo];
    rocket::build().mount(&quot;/&quot;, routes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣就可以正常運作了，接下來我們就來看看怎麼測試這個 API。&lt;/p&gt;

&lt;h2 id=&quot;part-6542dc564a6&quot;&gt;測試&lt;/h2&gt;

&lt;p&gt;我們可以在終端機使用 &lt;code&gt;curl&lt;/code&gt; 來測試，或者我們可以直接用 Postman 來測試，這邊我們就用 Postman 來操作。&lt;/p&gt;

&lt;p&gt;首先我們先啟動 server，然後會顯示以下的畫面，代表我們剛剛建立的 methods 已經在 routes 中運作了：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/EqeW1mr.png&quot; alt=&quot;CleanShot 2022-10-09 at 02.43.05@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;接下來我們就來測試一下，首先我們先用 &lt;code&gt;GET&lt;/code&gt; 的方式來取得所有的資料：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/qvpEJBI.png&quot; alt=&quot;CleanShot 2022-10-09 at 02.55.53@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;接下來我們用 &lt;code&gt;GET&lt;/code&gt; 的方式來取得 id 為 1 的資料：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/yZqOOp1.png&quot; alt=&quot;CleanShot 2022-10-09 at 02.58.43@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;目前我們使用 &lt;code&gt;GET&lt;/code&gt; 的方式都能成功取到資料，接下來我們就來測試 &lt;code&gt;POST&lt;/code&gt; 的方式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/SQvTpPN.png&quot; alt=&quot;CleanShot 2022-10-09 at 03.46.38@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;記得這裡的 key 要使用 Content-Type，value 要使用 application/json，這樣才能正常運作。&lt;/p&gt;

&lt;p&gt;接下來繼續接著測試 &lt;code&gt;PUT&lt;/code&gt; 的方式：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/FO7VQBG.png&quot; alt=&quot;CleanShot 2022-10-09 at 03.53.26@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;接著我們來測試 &lt;code&gt;DELETE&lt;/code&gt; 的方式：&lt;/p&gt;

&lt;p&gt;這裡我用 Postman 在測試的時候，由於是假資料，所以沒辦法得知是否成功，所以我們這裡改用 &lt;code&gt;curl&lt;/code&gt; 來測試：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ curl 127.0.0.1:8000/demo/1 -X DELETE -I
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;成功的話會回傳以下結果：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/ghnNHkF.png&quot; alt=&quot;CleanShot 2022-10-09 at 04.20.04@2x&quot;&gt;&lt;/p&gt;

&lt;h2 id=&quot;catch-error&quot;&gt;catch error&lt;/h2&gt;

&lt;p&gt;最後我們再做個如果開發者在打 API 時，輸入錯誤路徑的自定義錯誤訊息。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[catch(404)]
fn not_found() -&amp;gt; Value {
    json!({ &quot;status&quot;: &quot;error&quot;, &quot;reason&quot;: &quot;Resource was not found.&quot; })
}

#[launch]
fn rocket() -&amp;gt; _ {
    let routes = routes![get_demo, view_demo, create_demo, update_demo, delete_demo];
    rocket::build().mount(&quot;/&quot;, routes).register(&quot;/&quot;, catchers![not_found])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這樣如果打錯 API 的話，就會出現我們剛剛定義的錯誤 JSON 訊息。&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/5IWXuYb.png&quot; alt=&quot;CleanShot 2022-10-09 at 19.01.11@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;以下放上今天完整的程式碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[macro_use]
extern crate rocket;

use rocket::response::status;
use rocket::serde::json::{json, Json, Value};

#[get(&quot;/demo&quot;)]
fn get_demo() -&amp;gt; Value {
    json!([{ &quot;id&quot;: 1, &quot;name&quot;: &quot;Bucky&quot; }, { &quot;id&quot;: 2, &quot;name&quot;: &quot;Tom&quot; }])
}

#[get(&quot;/demo/&amp;lt;id&amp;gt;&quot;)]
fn view_demo(id: i32) -&amp;gt; Value {
    json!({ &quot;id&quot;: id, &quot;name&quot;: &quot;Some one&quot; })
}

#[post(&quot;/demo&quot;, format = &quot;json&quot;)]
fn create_demo() -&amp;gt; Value {
    json!({ &quot;id&quot;: 3, &quot;name&quot;: &quot;Patty&quot; })
}

#[put(&quot;/demo/&amp;lt;id&amp;gt;&quot;, format = &quot;json&quot;)]
fn update_demo(id: i32) -&amp;gt; Value {
    json!({ &quot;id&quot;: id, &quot;name&quot;: &quot;Bucky&quot; })
}

#[delete(&quot;/demo/&amp;lt;id&amp;gt;&quot;)]
fn delete_demo(id: i32) -&amp;gt; status::NoContent {
    status::NoContent
}

#[catch(404)]
fn not_found() -&amp;gt; Value {
    json!({ &quot;status&quot;: &quot;error&quot;, &quot;reason&quot;: &quot;Resource was not found.&quot; })
}

#[launch]
fn rocket() -&amp;gt; _ {
    let routes = routes![get_demo, view_demo, create_demo, update_demo, delete_demo];
    rocket::build().mount(&quot;/&quot;, routes).register(&quot;/&quot;, catchers![not_found])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;今天就先到這邊，明天來做 token 驗證的功能。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Wed, 12 Oct 2022 00:39:16 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-rocket-part-ii.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 2 minutes</category>
    </item>
    <item>
      <title>來玩 Rust 的框架吧！ - Rocket - Part I</title>
      <link>https://railquill.vercel.app/rust-rocket-part-i.html</link>
      <description>Rust 的框架 Rocket</description>
      <content:encoded><![CDATA[
        &lt;p&gt;今天開始我們將會開始使用 Rust 的 Web 框架 -- &lt;a href=&quot;https://rocket.rs/&quot;&gt;Rocket&lt;/a&gt;，來建立一個簡單的 Web Server。&lt;/p&gt;

&lt;h2 id=&quot;rocket&quot;&gt;Rocket 是什麼？&lt;/h2&gt;

&lt;p&gt;簡單介紹一下 Rocket，Rocket 是一個基於 Rust 語言的一個 Web 框架，截止目前為止在 GitHub 上一共有 18.6k 的星星數。&lt;/p&gt;

&lt;p&gt;Rocket 的設計靈感來自於 Ruby on Rails、Flask等知名的 Web 框架，並且在設計上有著類似的特性，並以 3 個核心概念來設計：&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;安全、正確，還有重視開發者體驗。&lt;/li&gt;
&lt;li&gt;所有的請求都會由 Rocket 來處理型別。&lt;/li&gt;
&lt;li&gt;不強制使用 Rocket 的函式庫，可以讓開發者自由選擇。&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;然後個人覺得 Rocket 的文件寫的非常的完整，算是蠻適合新手入門的一個框架。&lt;/p&gt;

&lt;h2 id=&quot;hello-world&quot;&gt;從 Hello World 開始&lt;/h2&gt;

&lt;p&gt;那麼我們就從一個簡單的 Hello World 開始，首先我們先建立一個 binary-based 的新專案：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;bash&quot;&gt;$ cargo new --bin rocket-server
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&quot;rocket&quot;&gt;安裝 Rocket&lt;/h3&gt;

&lt;p&gt;在 Rust 安裝套件非常容易，只要在 &lt;code&gt;Cargo.toml&lt;/code&gt; 裡面 &lt;code&gt;[dependencies]&lt;/code&gt; 的下方加入我們要安裝的套件就可以了，在這裡像這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml&quot;&gt;[dependencies]
rocket = &quot;0.5.0-rc.2&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後在 &lt;code&gt;main.rs&lt;/code&gt; 修改一下 code：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[macro_use] extern crate rocket;

#[get(&quot;/&quot;)]
fn index() -&amp;gt; &amp;amp;&#39;static str {
    &quot;Hello, world!&quot;
}

#[launch]
fn rocket() -&amp;gt; _ {
    rocket::build().mount(&quot;/&quot;, routes![index])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著在終端機輸入 &lt;code&gt;cargo run&lt;/code&gt;，一開始會先下載 Rocket 的套件，然後會接著執行程式，終端機的畫面會是這樣：&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;https://i.imgur.com/tfrH2pz.png&quot; alt=&quot;CleanShot 2022-10-08 at 15.44.16@2x&quot;&gt;&lt;/p&gt;

&lt;p&gt;都沒問題的話，可以按照提示連去網址，或是去 &lt;code&gt;http://localhost:8000&lt;/code&gt;，就可以看到我們的瀏覽器顯示出 Hello World 了。（雖然畫面有點陽春┐(´д`)┌）&lt;/p&gt;

&lt;p&gt;以上就是使用 Rocket 建立一個簡單的 Hello World，跟之前用純 Rust 相比是不是感受到他的方便呢？&lt;/p&gt;

&lt;p&gt;稍微講解一下剛剛運作的 code，首先我們先引入 Rocket 的套件：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[macro_use] extern crate rocket;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後我們定義一個 &lt;code&gt;index&lt;/code&gt; 的函式，並且回傳一個 &lt;code&gt;&amp;amp;&#39;static str&lt;/code&gt;，這個 &lt;code&gt;&amp;amp;&#39;static str&lt;/code&gt; 代表的是一個字串的 reference，而且這個 reference 的生命週期是 &lt;code&gt;&#39;static&lt;/code&gt;，也就是整個程式的生命週期。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[get(&quot;/&quot;)]
fn index() -&amp;gt; &amp;amp;&#39;static str {
    &quot;Hello, world!&quot;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;然後在 &lt;code&gt;#[launch]&lt;/code&gt; 的函式裡面，我們使用 &lt;code&gt;rocket::build()&lt;/code&gt; 來建立一個 Rocket 的實例，然後使用 &lt;code&gt;mount&lt;/code&gt; 來將我們的 &lt;code&gt;index&lt;/code&gt; 函式 mount 到 &lt;code&gt;/&lt;/code&gt; 的路徑上，最後回傳這個 Rocket 實例。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[launch]
fn rocket() -&amp;gt; _ {
    rocket::build().mount(&quot;/&quot;, routes![index])
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Rocket 在這裡也提供了另一種啟動 server 的寫法：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[rocket::main]
async fn main() -&amp;gt; Result&amp;lt;(), rocket::Error&amp;gt; {
    let _rocket = rocket::build()
        .mount(&quot;/&quot;, routes![index])
        .launch()
        .await?;

    Ok(())
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;兩者都可以運行，但是我覺得 &lt;code&gt;#[launch]&lt;/code&gt; 的寫法比較簡潔，不過還是有些許的差異，例如 &lt;code&gt;#[launch]&lt;/code&gt; 會自動幫你建立一個 &lt;code&gt;main&lt;/code&gt; 函式，而如果使用 &lt;code&gt;#[rocket::main]&lt;/code&gt; 的話，開發者自己處理的部分可能就比較多，端看個人喜好。&lt;/p&gt;

&lt;h2 id=&quot;json-response&quot;&gt;JSON response&lt;/h2&gt;

&lt;p&gt;前面我們都只是回傳一個字串，但是如果我們要回傳一個 JSON 的話，該怎麼做呢？&lt;/p&gt;

&lt;p&gt;這裡我們可以使用 &lt;a href=&quot;https://github.com/serde-rs/serde&quot;&gt;Serde&lt;/a&gt; 這個框架來幫忙處理 JSON，首先我們要先在 &lt;code&gt;Cargo.toml&lt;/code&gt; 裡面加入，並且修改一下，這裡幫大家整理好了：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;toml&quot;&gt;[dependencies]
rocket = { version = &quot;0.5.0-rc.2&quot;, features = [&quot;json&quot;] }
serde = { version = &quot;1.0&quot;, features = [&quot;derive&quot;] }
serde_json = &quot;1.0&quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著在 &lt;code&gt;main.rs&lt;/code&gt; 裡面修改一下：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;#[macro_use]
extern crate rocket;

use rocket::serde::json::{json, Json, Value};

#[get(&quot;/&quot;)]
fn index() -&amp;gt; Value {
    json!({ &quot;name&quot;: &quot;Bucky&quot;, &quot;age&quot;: 18, &quot;favorite_games&quot;: [&quot;splatoon 3&quot;, &quot;zelda&quot;] })
}

#[launch]
fn rocket() -&amp;gt; _ {
    let routes = routes![index];
    rocket::build().mount(&quot;/&quot;, routes)
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;接著一樣重新執行，然後瀏覽器重新整理，就可以看到回傳的 JSON 了。&lt;/p&gt;

&lt;p&gt;今天就先到這邊，明天再繼續建立一個簡單 CRUD 的 API。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Tue, 11 Oct 2022 01:10:50 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-rocket-part-i.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 2 minutes</category>
    </item>
    <item>
      <title>來用 Rust 建立一個伺服器吧！Part IV</title>
      <link>https://railquill.vercel.app/rust-part-iv.html</link>
      <description>用 Rust 建立一個伺服器</description>
      <content:encoded><![CDATA[
        &lt;p&gt;昨天我們新增了一個檔案，專門來做執行緒池的部分，但還沒完成，所以今天就接著繼續完成。&lt;/p&gt;

&lt;h2 id=&quot;part-101b2b48a8b529f9&quot;&gt;建立執行緒池的儲存空間&lt;/h2&gt;

&lt;p&gt;首先我們要建立一個儲存執行緒的空間，這個空間會儲存所有的執行緒，然後我們可以從這個空間取出執行緒來使用。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use std::thread::JoinHandle;

pub struct ThreadPool {
    threads: Vec&amp;lt;JoinHandle&amp;lt;()&amp;gt;&amp;gt;,
}

impl ThreadPool {
    pub fn new(size: usize) -&amp;gt; ThreadPool {
        assert!(size &amp;gt; 0);
        let mut threads = Vec::with_capacity(size);
        for _ in 0..size {
            // 產生執行緒並儲存至向量
        }
        ThreadPool { threads }
    }

    pub fn execute&amp;lt;F&amp;gt;(&amp;amp;self, f: F)
    where
        F: FnOnce() + Send + &#39;static,
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這邊我們先建立一個 &lt;code&gt;ThreadPool&lt;/code&gt; 的結構，然後在裡面建立一個 &lt;code&gt;threads&lt;/code&gt; 的向量，這個向量會儲存所有的執行緒，然後我們會在 &lt;code&gt;new&lt;/code&gt; 方法中產生執行緒並儲存至向量中。&lt;/p&gt;

&lt;h2 id=&quot;part-ef217caaef37de35&quot;&gt;完成執行緒池的建立&lt;/h2&gt;

&lt;p&gt;接下來就直接先上完成的 code，然後再來解釋。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use std::sync::{
    mpsc::{self, Receiver, Sender},
    Arc, Mutex,
};
use std::thread::{self, JoinHandle};

type Job = Box&amp;lt;dyn FnOnce() + Send + &#39;static&amp;gt;;

pub struct ThreadPool {
    workers: Vec&amp;lt;Worker&amp;gt;,
    sender: Sender&amp;lt;Job&amp;gt;,
}

impl ThreadPool {
    pub fn new(size: usize) -&amp;gt; ThreadPool {
        assert!(size &amp;gt; 0);

        let (sender, receiver) = mpsc::channel();

        let receiver = Arc::new(Mutex::new(receiver));

        let mut workers = Vec::with_capacity(size);

        for id in 0..size {
            workers.push(Worker::new(id, receiver.clone()));
        }

        ThreadPool { workers, sender }
    }

    pub fn execute&amp;lt;F: FnOnce() + Send + &#39;static&amp;gt;(&amp;amp;self, f: F) {
        let job = Box::new(f);

        self.sender.send(job).unwrap();
    }
}

struct Worker {
    id: usize,
    thread: JoinHandle&amp;lt;()&amp;gt;,
}

impl Worker {
    fn new(id: usize, receiver: Arc&amp;lt;Mutex&amp;lt;Receiver&amp;lt;Job&amp;gt;&amp;gt;&amp;gt;) -&amp;gt; Worker {
        let thread = thread::spawn(move || loop {
            let job = receiver.lock().unwrap().recv().unwrap();

            println!(&quot;Worker {} got a job; executing.&quot;, id);

            job();
        });

        Worker { id, thread }
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;首先，從 &lt;code&gt;use&lt;/code&gt; 引入的部分，我們引入了 &lt;code&gt;mpsc&lt;/code&gt; 的 channel，這個 channel 會用來傳遞執行緒的工作，然後我們也引入了 &lt;code&gt;Arc&lt;/code&gt; 和 &lt;code&gt;Mutex&lt;/code&gt;，這兩個是用來做多執行緒的共享資源的。&lt;/p&gt;

&lt;p&gt;接下來，我們定義了一個 &lt;code&gt;Job&lt;/code&gt; 的型別，這個型別是一個 &lt;code&gt;Box&lt;/code&gt;，裡面放的是一個 &lt;code&gt;FnOnce&lt;/code&gt; 的 trait，這個 trait 會用來定義執行緒的工作，然後我們會在 &lt;code&gt;execute&lt;/code&gt; 方法中將這個 trait 傳遞給 channel。&lt;/p&gt;

&lt;p&gt;再來，我們在 &lt;code&gt;ThreadPool&lt;/code&gt; 的結構中，新增了一個 &lt;code&gt;workers&lt;/code&gt; 的向量，這個向量會儲存所有的執行緒，然後我們會在 &lt;code&gt;new&lt;/code&gt; 方法中產生執行緒並儲存至向量中。&lt;/p&gt;

&lt;p&gt;接著，我們在 &lt;code&gt;new&lt;/code&gt; 方法中，先建立一個 channel，然後我們會將 channel 的接收端傳入執行緒中，這樣執行緒就可以從 channel 中取得工作了。&lt;/p&gt;

&lt;p&gt;最後，我們在 &lt;code&gt;execute&lt;/code&gt; 方法中，將工作傳遞給 channel。&lt;/p&gt;

&lt;h2 id=&quot;part-f6316b6da270bb02&quot;&gt;執行緒池的測試&lt;/h2&gt;

&lt;p&gt;接下來，我們來測試一下我們的執行緒池。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;// src/main.rs
extern crate server;
use std::io::prelude::*;
use std::net::{TcpListener, TcpStream};
use std::{fs, path::Path, thread, time::Duration};
use server::ThreadPool;

const PORT: i32 = 3000;
const WORKER_SIZE: usize = 4; // 這裡設定執行緒數量

fn main() {
    let listener = TcpListener::bind(format!(&quot;127.0.0.1:{}&quot;, PORT)).unwrap();
    let pool = ThreadPool::new(WORKER_SIZE);

    for stream in listener.incoming() {
        let stream = stream.unwrap();
        pool.execute(|| { handle_connection(stream); });
    }
}

// 省略...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;現在當我們執行程式，並且在瀏覽器開啟多個分頁，我們可以透過終端機來觀察執行緒池的執行情況，並且可以發現，現在可以非同步處理多個連線，而且收到大量請求時，也不會因為執行緒不夠而導致無法回應。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Mon, 10 Oct 2022 01:03:43 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-part-iv.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 2 minutes</category>
    </item>
    <item>
      <title>來用 Rust 建立一個伺服器吧！Part III</title>
      <link>https://railquill.vercel.app/rust-part-iii.html</link>
      <description>用 Rust 建立一個伺服器</description>
      <content:encoded><![CDATA[
        &lt;p&gt;在開始建立多執行緒伺服器之前，我們先來模擬一下單一執行緒伺服器會遇到的問題。&lt;/p&gt;

&lt;h2 id=&quot;part-42c56d393b7e400f&quot;&gt;模擬請求問題&lt;/h2&gt;

&lt;p&gt;直接上 code 吧！&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;use std::thread; // 引入 thread 模組
use std::time::Duration; // 引入 Duration 模組

// 省略...
fn handle_connection(mut stream: TcpStream) {
    // 省略...
    let delay = b&quot;GET /delay HTTP/1.1\r\n&quot;;

    let (status_line, path) = if buffer.starts_with(get) {
        (&quot;HTTP/1.1 200 OK&quot;, Path::new(&quot;./src/HTML/hello.html&quot;))
    } else if buffer.starts_with(delay) {
        thread::sleep(Duration::from_secs(10)); // 這裡讓執行緒睡 10 秒
        (&quot;HTTP/1.1 200 OK&quot;, Path::new(&quot;./src/HTML/delay.html&quot;)) // 這裡我們要新增一個 HTML 檔案來顯示延遲的內容
    } else {
        (&quot;HTTP/1.1 404 NOT FOUND&quot;, Path::new(&quot;./src/HTML/404.html&quot;))
    };
    // 省略...
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這邊我們新增了一個 &lt;code&gt;/delay&lt;/code&gt; 的路徑，當我們輸入 &lt;code&gt;http://127.0.0.1:3000/delay&lt;/code&gt; 時，會延遲個 10 秒，然後回傳延遲的內容。
而在這一頁重整的話，也一樣會發現我們的網頁會一直在等待，直到 10 秒後才會回傳內容。&lt;/p&gt;

&lt;p&gt;然後我們另外開一個分頁，這裡我們輸入 &lt;code&gt;http://127.0.0.1:3000/&lt;/code&gt;，然後會正常無延遲顯示 &lt;code&gt;hello.html&lt;/code&gt; 的內容。
這時候我們來做一個有趣的事情，我們在 &lt;code&gt;/delay&lt;/code&gt; 的分頁重整，然後在 &lt;code&gt;/&lt;/code&gt; 的分頁重整，我們會發現 &lt;code&gt;/&lt;/code&gt; 的分頁也會等待 10 秒，然後才會回傳內容。&lt;/p&gt;

&lt;p&gt;這就是我們要解決的問題，我們的伺服器只有一個執行緒，所以當有一個請求進來時，其他的請求都會等待，直到這個請求處理完畢。&lt;/p&gt;

&lt;h2 id=&quot;part-4f4c94244a6946ee&quot;&gt;建立多執行緒伺服器&lt;/h2&gt;

&lt;h3 id=&quot;thread-spawn&quot;&gt;使用 thread::spawn&lt;/h3&gt;

&lt;p&gt;這邊我們可以先使用 &lt;code&gt;thread::spawn&lt;/code&gt; 來建立多執行緒，讓我們的伺服器可以同時處理多個請求。&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;// 省略...
use std::thread; // 引入 thread 模組

fn main() {
    let listener = TcpListener::bind(format!(&quot;127.0.0.1:{}&quot;, PORT)).unwrap();

    for stream in listener.incoming() {
        let stream = stream.unwrap();

        thread::spawn(|| handle_connection(stream)); // 這邊我們使用 thread::spawn 來建立多執行緒
    }
}

// 省略...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這裡的作法是，因為我們的 HTTP 請求都寫在 &lt;code&gt;handle_connection&lt;/code&gt; 這個函式裡面，所以我們可以直接將 &lt;code&gt;handle_connection&lt;/code&gt; 這個函式傳入 &lt;code&gt;thread::spawn&lt;/code&gt; 來建立多執行緒。這樣每次建立一個新的 TCP 連線時，我們就會建立一個新的執行緒來處理這個請求。&lt;/p&gt;

&lt;p&gt;然後我們來測試一下剛剛的情況，現在一樣開兩個分頁，這時候等待 10 秒結束 &lt;code&gt;/delay&lt;/code&gt; 的分頁一樣會等待 10 秒才 loading 完畢，但是 &lt;code&gt;/&lt;/code&gt; 的分頁不會等待，因為我們的伺服器已經可以同時處理多個請求了。&lt;/p&gt;

&lt;p&gt;不過雖然現在的作法可行，但是由於每次建立一個新的 TCP 連線時，我們就會建立一個新的執行緒來處理這個請求，所以如果有大量的請求進來，例如 DDOS 攻擊我們的伺服器，這樣就會瞬間建立大量的執行緒，會造成效能上的問題。&lt;/p&gt;

&lt;p&gt;而解決的方法有很多種，這邊我們選擇使用執行緒池（thread pool）的方式來解決。&lt;/p&gt;

&lt;p&gt;但在開始之前，我們先來看一下執行緒池的概念。&lt;/p&gt;

&lt;h3 id=&quot;part-530d088b9932f11&quot;&gt;什麼是執行緒池？&lt;/h3&gt;

&lt;p&gt;簡單說明一下，執行緒池是執行緒的一種執行模式，執行緒池的概念就是我們先建立一個執行緒池，然後把固定數量的執行緒放進去。當有請求進來時，我們就從執行緒池中取出一個執行緒來處理請求，這時候其他的執行緒也可以處理其他的請求，而當執行緒請求處理完畢後，執行緒會回到執行緒池中等待新的請求。&lt;/p&gt;

&lt;p&gt;執行緒池的好處就是我們可以讓多個執行緒同時處理請求，而不會因為單一執行緒的問題而造成等待，並且可以控制執行緒的數量，避免大量的執行緒造成效能上的問題。&lt;/p&gt;

&lt;p&gt;那麼了解了執行緒池的概念後，我們就可以來實際操作藉由執行緒池來建立多執行緒的伺服器了。&lt;/p&gt;

&lt;h3 id=&quot;part-6542aca06bc&quot;&gt;實作&lt;/h3&gt;



&lt;p&gt;首先我們可以先在 &lt;code&gt;src&lt;/code&gt; 的目錄下新增一個 &lt;code&gt;lib.rs&lt;/code&gt; 的檔案，接著來寫執行緒池的程式碼：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;// src/lib.rs
pub struct ThreadPool;

impl ThreadPool {
    pub fn new(size: usize) -&amp;gt; ThreadPool {
        assert!(size &amp;gt; 0);

        ThreadPool
    }

    pub fn execute&amp;lt;F&amp;gt;(&amp;amp;self, f: F)
    where
        F: FnOnce() + Send + &#39;static,
    {
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;這邊我們先建立一個 &lt;code&gt;ThreadPool&lt;/code&gt; 的結構，然後在 &lt;code&gt;ThreadPool&lt;/code&gt; 的結構中實作一個 &lt;code&gt;new&lt;/code&gt; 方法，這個方法會接收一個 &lt;code&gt;usize&lt;/code&gt; 的參數，代表我們要建立幾個執行緒，然後在 &lt;code&gt;new&lt;/code&gt; 方法中我們會先使用 &lt;code&gt;assert!&lt;/code&gt; 來確認我們傳入的參數是否大於 0，如果不是的話就會 panic 掉，然後我們會回傳一個 &lt;code&gt;ThreadPool&lt;/code&gt; 的結構。&lt;/p&gt;

&lt;p&gt;接著我們想要在 &lt;code&gt;ThreadPool&lt;/code&gt; 的結構中要有一個類似 &lt;code&gt;thread::spawn&lt;/code&gt; 的方法，可以從參數傳入要在新執行緒開啟的閉包，他的文件是這樣：&lt;/p&gt;

&lt;pre&gt;&lt;code class=&quot;rust&quot;&gt;pub fn spawn&amp;lt;F, T&amp;gt;(f: F) -&amp;gt; JoinHandle&amp;lt;T&amp;gt;
    where
        F: FnOnce() -&amp;gt; T,
        F: Send + &#39;static,
        T: Send + &#39;static,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;所以我們在 &lt;code&gt;ThreadPool&lt;/code&gt; 的結構中實作一個 &lt;code&gt;execute&lt;/code&gt; 方法，這個方法會接收一個泛型 &lt;code&gt;F&lt;/code&gt;，這個泛型 &lt;code&gt;F&lt;/code&gt; 會是一個閉包，而這個閉包的型別會是 &lt;code&gt;FnOnce()&lt;/code&gt;，也就是說這個閉包不會接收任何參數，也不會回傳任何值，而且這個閉包只會執行一次。而這個閉包的型別也會是 &lt;code&gt;Send&lt;/code&gt;，也就是說這個閉包可以在多執行緒中安全的傳遞，而且這個閉包的型別也會是 &lt;code&gt;&#39;static&lt;/code&gt;，也就是說這個閉包的生命週期會是整個程式的生命週期。&lt;/p&gt;

&lt;p&gt;今天先做到這邊，我們明天再繼續接著做。&lt;/p&gt;

      ]]></content:encoded>
      <pubDate>Sun, 09 Oct 2022 04:41:24 +0000</pubDate>
      <guid isPermaLink="true">https://railquill.vercel.app/rust-part-iii.html</guid>
      <author>bucky0112@gmail.com (Bucky Chu)</author>
      <category>Reading Time: 2 minutes</category>
    </item>
  </channel>
</rss>